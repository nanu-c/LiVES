#!/usr/bin/perl

# smogrify - Copyright G. Finch 2003 - 2009
# Released under the GPL 3 or later - see file COPYING or www.gnu.org for details


##################################################################

# these MUST match with the definition in the GUI
$rc_filename=".lives";

$rfx_builder_multi="build-lives-rfx-plugin-multi";

# default temporary directory (can be overridden from the GUI)
$default_tmpdir="/tmp/livestmp/";

$umask=0177; # ->        -rw-------

$GUI_NAME="LiVES";

###################################################################

# default values
$encoder="mencoder_encoder";

$composite_command="composite -quiet -colorspace RGB -type truecolor";

# TODO - use <effect_command>, add colorspace if it is eq convert
$convert_command="convert -quiet -colorspace RGB -type truecolor";

###################################################################
# Do not change these except for testing !

$background=1;
$version="1.3.3-svn";
#$dyneversion="LIVES-20091209";


###################################################################


$uid=$>;
$gid=$);
$gid=~ s/\W.*//;

$home=$ENV{"HOME"};


###################################################################

if (defined($ARGV[0])) {
    $command=$ARGV[0];

    unless ($command eq "report"||$command eq "version") {
	$tmpdir=&rc_get("tempdir");
    }

    if (!caller||$command eq "save"||$command eq "plugin_clear") {
	if (defined $DEBUG_SM_CMDS) { 
	    print STDERR "command is $command\n";
	}

	if ($command eq "save" && $ARGV[1] eq "get_rfx") {
	    $background=0;
	}


## blocking calls


    if ($command eq "stopsubsub"||$command eq "stopsubsubs"||$command eq "stop_audio") {
	$handle=$ARGV[1];
	$curtmpdir="$tmpdir/$handle";
	if ($command eq "stop_audio") {
		$pidfile="$curtmpdir/.pidpb";
	}
	else {
		$pidfile="$curtmpdir/.pid";
	}
	$statusfile="$curtmpdir/.status";
	$wait_for_pid=1;
	if (defined $ARGV[2]) {
	    $wait_for_pid=-1;
	}

	unless (-d "$curtmpdir") {
	    exit 2;
	}
	if (defined(open IN,"< $pidfile")) {
	    read IN,$target_pid,8;
	    close IN;
	    if ($target_pid eq NULL) {
		exit 1;
	    }
	    # make sure pidfile has same group and owner, otherwise exit
	    @stat=stat($pidfile);
	    if (!($uid==$stat[4]&&$gid==$stat[5])) {
		die "Smogrify: Unable to stop process $target_pid.\n";
	    }
	    elsif ($command eq "stopsubsub"||$command eq "stop_audio") {
		# kill all subprocesses of target_pid, and target_pid
		&kill_child_pids($target_pid);
	    }
	    elsif ($command eq "stopsubsubs") {
		# kill all subprocesses of target_pid, but not target_pid
		`pgrep -P $target_pid > $tmpdir/.pids.$target_pid`;
		if (-s "$tmpdir/.pids.$target_pid"&&defined(open IN,"$tmpdir/.pids.$target_pid")) {
		    while (<IN>) {
			$pid=$_;
			chomp($pid);
			&kill_child_pids($pid);
		    }
		    close IN;
		}
		unlink "$tmpdir/.pids.$target_pid";
	    }
	    
	    else {
		print "Attempting to stop process ".$target_pid." with $command\n";
		system("kill -TERM $target_pid>/dev/null 2>&1");
	    }
	    
	    unlink $pidfile;
	    unless ($command eq "stop_audio") {
		&sig_killed;
	    }
	    exit 0;
	}
	exit 1;
    }


    if ($command eq "pause_play") {
	`kill -STOP mplayer`;
	`kill -STOP sox`;
	exit 0;
    }

    if ($command eq "resume_play") {
	`kill -CONT mplayer`;
	`kill -CONT sox`;
	exit 0;
    }


    if ($command eq "new") {
	# warning - this has changed recently, it now takes a $key
	# this can normally be set to getpid()

	$key=$ARGV[1];

	# write mini-info file
	$infofile=$tmpdir."/.info.".$key;
	
	do {
	    $handle=int(rand 1000000000)+65536;
	    $curtmpdir="$tmpdir/$handle";
	} while (-d $curtmpdir);
	
	umask 0;
	mkdir $curtmpdir,0700;
	umask $umask;
	
	if (!defined(open OUT,"> $infofile")) {
	    exit 1;
	}
	
	print OUT $handle;
	close OUT;
	exit 0;
    }
    

    if ($command eq "get_tempdir") {
	$id=$ARGV[1];
	print "> /tmp/.smogrify.$id\n";
	open OUT,"> /tmp/.smogrify.$id" or exit 1;
	print OUT "$tmpdir";
	close OUT;
	exit 0;
    }


    if ($command eq "report") {
	$gui_bootstrap_file="";
	if (defined($ARGV[1])) {
	    $gui_bootstrap_file=$ARGV[1];
	}

	$startup_phase=0;

	$video_open_command=&location("mplayer");

	$audio_player="sox";
	$audio_play_command=&rc_get_default("sox_command");
	    
	$convert_version_hash=&get_convert_version_hash;
	
	if ($audio_play_command eq "") {
	    $audio_player="mplayer";
	    $audio_play_command=&rc_get_default("mplayer_audio_command");
	}
	
	# get $tmpdir from .rc file, if no .rc file, create it
	if (! -s "$home/$rc_filename") {
	    # set comment at start of file
	    &rc_set("","");
	    $startup_phase=-1;
	    &rc_set("startup_phase",-1);
	}
	else {
	    $startup_phase=&rc_get("startup_phase");
	    if ($startup_phase eq "" || $startup_phase eq "100") {
		$startup_phase=0;
		&rc_delete("startup_phase");
	    }
	}

	$lives_home_dir="$home/.lives-dir/";
	$default_keymap="default.keymap";

	if (! -d "$lives_home_dir") {
	    mkdir ("$lives_home_dir",0700);
	}

	&rc_set_if_not_set("version",$version);
	&rc_set_if_not_set("tempdir",$default_tmpdir);

	if (defined($dyneversion)) {
	    &rc_set_if_not_set("lib_dir","/opt/$dyneversion/lib/");
	    &rc_set_if_not_set("prefix_dir","/opt/$dyneversion/");
	}

	&rc_set_if_not_set("video_open_command",$video_open_command);
	&rc_set_if_not_set("audio_play_command",$audio_play_command);
	&rc_set_if_not_set("audio_player",$audio_player);
	&rc_set_if_not_set("midisynch","false");
	&rc_set_if_not_set("pb_quality",2);
	&rc_set_if_not_set("insert_resample","true");
	&rc_set_if_not_set("open_compression_percent",15);
	&rc_set_if_not_set("conserve_space","false");
	&rc_set_if_not_set("antialias","true");
	# resize action when opening images - can be one of: "bound", "default" or "none"
	&rc_set_if_not_set("image_resize_action","none");
	&rc_set_if_not_set("encoder",$encoder);
	&rc_set_if_not_set("output_type","mjpeg");
	&rc_set_if_not_set("audio_effect","none");
	&rc_set_if_not_set("default_image_format","png");
	&rc_set_if_not_set("default_fps",25);
	&rc_set_if_not_set("vid_load_dir","$home");
	&rc_set_if_not_set("vid_save_dir","$home");
	&rc_set_if_not_set("image_dir","$home");
	&rc_set_if_not_set("proj_dir","$home");
	&rc_set_if_not_set("audio_dir","$home");
	&rc_set_if_not_set("save_directories","false");
	&rc_set_if_not_set("stop_screensaver","true");
	&rc_set_if_not_set("open_maximised","true");
	&rc_set_if_not_set("show_recent_files","true");
	&rc_set_if_not_set("ce_maxspect","true");
	&rc_set_if_not_set("lives_warning_mask",797696); # bits 19,18,13,11 and 10
	&rc_set_if_not_set("dl_bandwidth_K",512);
	&rc_set_if_not_set("show_player_stats","false");
	&rc_set_if_not_set("show_toolbar","true");
	&rc_set_if_not_set("encoder_acodec",1); # default of PCM
	&rc_set_if_not_set("record_opts",-1);

	&rc_set_if_not_set("gui_theme","crayons");
	&rc_set_if_not_set("jack_opts",0); # start aserver on startup
	&rc_set_if_not_set("audio_opts",3);
	&rc_set_if_not_set("rte_keys_virtual",9);

	&rc_set_if_not_set("instant_open","true");
	&rc_set_if_not_set("auto_deinterlace","true");

	&rc_set_if_not_set("mt_undo_buf",32);
	&rc_set_if_not_set("mt_enter_prompt","true");
	&rc_set_if_not_set("render_prompt","true");
	&rc_set_if_not_set("mt_exit_render","true");
	&rc_set_if_not_set("mt_def_width",640);
	&rc_set_if_not_set("mt_def_height",480);
	&rc_set_if_not_set("mt_def_achans",2);
	&rc_set_if_not_set("mt_def_signed_endian",2*!&get_endian);
	&rc_set_if_not_set("mt_backaudio","1");
	&rc_set_if_not_set("mt_pertrack_audio","true");
	&rc_set_if_not_set("mt_auto_back",30);

	&rc_set_if_not_set("ar_clipset","");
	&rc_set_if_not_set("ar_layout","");
	
	&rc_set_if_not_set("rec_desktop_audio","false");
	&rc_set_if_not_set("osc_start","false");
	&rc_set_if_not_set("osc_port",9999);

	&rc_set_if_not_set("concat_images","true");
	&rc_set_if_not_set("mouse_scroll_clips","true");

	&rc_set_if_not_set("omc_dev_opts",3);

	&rc_set_if_not_set("rec_stop_gb",10);


	$tmpdir=&rc_get("tempdir");
	&write_bootstrap_file;
	&mktmpdir;
	
	$convert_old_version=&rc_get("convert_version");
	unless ($convert_old_version eq $convert_version) {
	    &rc_set("convert_version",$convert_version);
	}
	&version_check_and_upgrade;



	unless ($gui_bootstrap_file eq "") {
	    open OUT,"> $gui_bootstrap_file" or exit 4;
	    print OUT "$version|$tmpdir|$startup_phase|$msg|$msg2";
	    close OUT;
	}

	#make sure we can write to tempir
	open OUT,"> $tmpdir/.test" or exit 5;
	close OUT;
	unlink "$tmpdir/.test";

	exit 0;
    }

	if ($command eq "set_clip_value") {
	    $prefs_file=$ARGV[1];
	    shift(@ARGV);
	    $command="set_pref";
	}


    if ($command eq "set_pref") {
	# WARNING - pref keys should not contain spaces, but values can
	$key=$ARGV[1];
	shift(@ARGV);
	shift(@ARGV);

	$value=join(" ",@ARGV);
	&rc_set($key,$value);
	exit 0;
    }
	
    if ($command eq "set_pref_if_not_set") {
	# WARNING - pref keys should not contain spaces, but values can
	$key=$ARGV[1];
	shift(@ARGV);
	shift(@ARGV);

	$value=join(" ",@ARGV);
	&rc_set_if_not_set($key,$value);
	exit 0;
    }
	


	if ($command eq "get_clip_value") {
	    $command="get_pref";
	    $prefs_file=$ARGV[4];
	}


	if ($command eq "print_pref") {
	    $command="get_pref";
	    $ARGV[2]="-";
	}

    if ($command eq "get_pref") {
	$key=$ARGV[1];
	if (defined($ARGV[2])) {
	    $first=$ARGV[2];
	}
	else {
	    $first=$uid;
	}
	if (defined($ARGV[3])) {
	    $second=$ARGV[3];
	}
	else {
	    $second=$gid;
	}
	$value=&rc_get($key,$home);

	if ($first eq "-"&&!defined($ARGV[3])) {
	    print $value;
	    exit 0;
	}

	open OUT,"> $tmpdir/.smogval.$first.$second" or exit 1;
	print OUT $value;
	close OUT;
	exit 0;
    }

    if ($command eq "get_pref_default") {
	$key=$ARGV[1];
	if (defined($ARGV[2])) {
	    $first=$ARGV[2];
	}
	else {
	    $first=$uid;
	}
	if (defined($ARGV[3])) {
	    $second=$ARGV[3];
	}
	else {
	    $second=$gid;
	}
	$value=&rc_get_default($key);
	open OUT,"> $tmpdir/.smogval.$first.$second" or exit 1;
	print OUT $value;
	close OUT;
	exit 0;
    }

    if ($command eq "get_location") {
	$exe=$ARGV[1];
	if (defined($ARGV[2])) {
	    $first=$ARGV[2];
	}
	else {
	    $first=$uid;
	}
	if (defined($ARGV[3])) {
	    $second=$ARGV[3];
	}
	else {
	    $second=$gid;
	}
	$value=&location($exe);
	open OUT,"> $tmpdir/.smogval.$first.$second" or exit 1;
	print OUT $value;
	close OUT;
	exit 0;
    }


	if ($command eq "xmmsstop") {
	$xmms_command=&location("xmms");
	unless ($xmms_command eq "") {
	    system("$xmms_command -s");
	}
	exit 0;
    }

    if ($command eq "xmmsplay") {
	$xmms_command=&location("xmms");
	unless ($xmms_command eq "") {
	    system("$xmms_command -p \"$ARGV[1]\" &");
	}
	exit 0;
    }

    if ($command eq "pause") {
	system("touch $tmpdir/$ARGV[1]/pause; chmod 600 $tmpdir/$ARGV[1]/pause");
	exit 0;
    }


    if ($command eq "resume") {
	unlink "$tmpdir/$ARGV[1]/pause";
	exit 0;
    }


	if ($command eq "clear_tmp_files") {
	    $handle=$ARGV[1];
	    #clear old backups (e.g. when saving a set)
	    $curtmpdir="$tmpdir/$handle";
	    &clean_old;
	    &sig_complete;
	    exit 0;
	}


    if ($command eq "undo_audio") {
	$handle=$ARGV[1];
	$curtmpdir="$tmpdir/$handle";
	$statusfile="$curtmpdir/.status";
	&undo_audio;
	&sig_complete;
	exit 0;
    }

    if ($command eq "backup_audio") {
	$handle=$ARGV[1];
	$curtmpdir="$tmpdir/$handle";
	$statusfile="$curtmpdir/.status";
	chdir $curtmpdir;
	&backup_audio;
	&sig_complete;
	exit 0;
    }


    if ($command eq "save_frame") {
	$handle=$ARGV[1];
	$curtmpdir="$tmpdir/$handle";
	$frame=$ARGV[2];
	$name=&mkname($frame);
	$nfile=$ARGV[3];
	$statusfile="$curtmpdir/.status";

	# check the file is writable
	unless (&is_writeable($nfile)) {
	    &sig_error("Unable to open output file !","$GUI_NAME could not write to $nfile.");
	}

	$img_ext=&get_img_ext($curtmpdir,$frame);

	system("$convert_command $curtmpdir/$name$img_ext \"$nfile\" >/dev/null 2>&1");
	exit 0;
    }


    if ($command eq "restore_details") {
	$handle=$ARGV[1];
	$nfile=$ARGV[2];
	$leave_headers=$ARGV[3];

	$curtmpdir="$tmpdir/$handle";
	$statusfile="$curtmpdir/.status";

	chdir $curtmpdir;
	$fsize= -s "$nfile";
	$afsize = -s "audio";
	unlink <*.tar>;
	unlink <event.*>;
	unlink "extended";

	$img_type="jpg";

	unless (-f "header.lives") {
	    
	    if (defined(open IN,"< header2")) {
		read IN,$val,4;
		
		# TODO - do not assume, store endianness in header !
		$endian=&get_endian;
		$frames=&getint($val);
		read IN,$title,256;
		read IN,$author,256;
		read IN,$comment,256;
	    }
	    
	    $title=~ tr/\x00//d;
	    $author=~ tr/\x00//d;
	    $comment=~ tr/\x00//d;
	    
	    # very old backups didn't have a header2
	    if (! -f "header2") {
		unless ($nfile eq "") {
		    unlink <event.*>;
		    $img_ext=&get_img_ext($curtmpdir);
		    $frames=&count_frames;
		}
	    }

	    # leave headers for restoring VJ sets
	    if ($leave_headers==1) {
		$fsize=0;
	    }
	    else {
		unlink <header header2>;
	    }
	}
	else {
	    unlink <header header2>;
	    
	}

	$name=&mkname(1);

	if (-f "$name.png") {
	    $img_type="png";
	}

	&sig_complete($fsize,$afsize,$img_type,$frames,"$title","$author","$comment");
	exit 0;
    }

    if ($command eq "list_plugins") {
	# prefix_dir pref should be set first
	# plugins are returned in sort() order

	my $allow_nonex=$ARGV[1];
	my $allow_subdirs=$ARGV[2];
	my $plugindir=$ARGV[3];
	my $ext=$ARGV[4];

	my $string="";

	if ($ext =~ /^-/) {
	    $strip_ext=1;
	    $ext=substr($ext,1,length($ext));
	}

	if (-d $plugindir) {
	    chdir $plugindir;
	    opendir DIR,$plugindir;
	    my @files=readdir(DIR);
	    closedir DIR;
	    @files = sort (@files);

	    foreach my $plugname (@files) {
		unless ($plugname =~ /^\./) {
		    if ((-f $plugname && (-x $plugname||$allow_nonex))||($allow_subdirs==1&& -d $plugname)) {
			unless($allow_nonex) {
			    next if ! -x "$plugindir/$plugname";
			}
			unless ($plugname eq "") {
			    if ($ext eq ""|| $plugname =~ /$ext$/) {
				if ($strip_ext==1) {
				    $plugname=(split(/\./,$plugname))[0];
				}
				$string.="$plugname|";
			    }
			}
		    }
		}
	    }
	}
	else {
	    exit 1;
	}
	print "$string\n";
	exit 0;
    }


	if ($command eq "build_rfx_plugins") {
	    if (&location($rfx_builder_multi) eq "") {
		&sig_error("Unable to locate the program $rfx_builder_multi");
		exit 1;
	    }

	    $type=$ARGV[1];
            $script_dir=$ARGV[2];
            $exec_dir=$ARGV[3];
	    system("$rfx_builder_multi $type $script_dir $exec_dir");
	    exit 0;
	}



	if ($command eq "make_thumb") {
	    $handle=$ARGV[1];
	    $curtmpdir="$tmpdir/$handle";
	    $statusfile="$curtmpdir/.status";
	    $dwidth=$ARGV[2];
	    $dheight=$ARGV[3];
	    $img_ext=".".$ARGV[4];
	    $file=$ARGV[5];

	    if (! -d "$curtmpdir") {
		mkdir ("$curtmpdir",0700);
	    }

	    $antialias=&rc_get("antialias");

	    $imresact="bound";
	    &get_image_size("$file");
	    if (!($vsize*$hsize)) {
		&sig_complete(0,0);
		exit 0;
	    }

	    chdir $curtmpdir;

	    $name=&mkname(1);
	    
	    if ($antialias eq "false") {
		system("$convert_command +antialias \"$file\" -scale $hsize"."!x"."$vsize! $curtmpdir/$name$img_ext > /dev/null 2>&1");
	    }
	    else {
		system("$convert_command -antialias \"$file\" -resize $hsize"."!x"."$vsize! $curtmpdir/$name$img_ext > /dev/null 2>&1");
	    }
	    &sig_complete($hsize,$vsize);
	    exit 0;
	}


	if ($command eq "version"&&!caller) {
	    print "smogrify $version\n";
	    exit 0;
	}


	if ($command eq "plugin_clear") {
	    # this is a special function which does general cleanup
	    # and then does the "clear" command in the plugin
	    # non-perl plugins have to implement this command themselves
	    #
	    $handle=$ARGV[1];
	    $curtmpdir="$tmpdir/$handle";
	    $statusfile=$curtmpdir."/.status";
	    chdir $curtmpdir;
	    $start=$ARGV[2];
	    $end=$ARGV[3];
	    $plugdir=$ARGV[4];
	    $type=$ARGV[5];
	    $rest=$ARGV[6];
	    $plugin="";
	    unless ($rest eq "") {
		$plugin="$plugdir$type/$rest";
	    }

	    if ($type eq "encoders") {
		$img_ext=&get_img_ext($curtmpdir,$start);

		if (-f "audio.origbak") {
		    unlink "audio";
		    rename "audio.origbak","audio";
		}
		$areq=&get_form_request($plugin);
		if ($areq&1||$areq&2) {
		    unlink <audiodump.wav audioclip>;
		}
		if ($areq&4) {
		    &clear_symlinks;
		}
	    }

	    #need this again - something resets us
	    chdir $curtmpdir;

	    if ($plugin eq "") {
		# let the plugin clean up any other temp files
		$command="clear";
		return 1;
	    }
	    else {
		system("$plugin clear $start $end $img_ext");
		&sig_complete;
		exit 0;
	    }
	}



	if ($command eq "check_for_lock") {
	    # check if there is a lock file for a set, and if so is it in use
	    my $setname=$ARGV[1];
	    my $exename=$ARGV[2];
	    my $pid=$ARGV[3];

            opendir DIR,"$tmpdir/$setname";

	    while (my $file=readdir(DIR)) {
		if ($file=~/^lock\.(.*)/) {
		    #found a lockfile
		    my $proc=$1;
		    unless ($proc eq $pid) {
			my $exe=`readlink -n /proc/$proc/exe`;
			my $short_exe=&my_basename($exe);
			if ($short_exe eq $exename) {
			    # and it's in use
			    closedir DIR;
			    print $proc."\n";
			    exit 1;
			}
			unlink "$tmpdir/$setname/$file";
		    }
		}
	    }
            closedir DIR;
	    exit 0;
	}





	if ($command eq "get_recovery_file") {
	    #find first non-in-use recovery file for given uid, gid and filepart
	    my $uid=$ARGV[1];
	    my $gid=$ARGV[2];
	    my $exename=$ARGV[3];
	    my $filepart=$ARGV[4];
            opendir DIR,"$tmpdir";

	    while (my $file=readdir(DIR)) {
		if ($file=~/^$filepart\.$uid\.$gid\.(.*)/) {
		    if (-z $file) {
			unlink $file;
		    }
		    else {
			my $exe=`readlink -n /proc/$1/exe`;
			my $short_exe=&my_basename($exe);
			
			unless ($short_exe eq $exename) {
			    $output=(split /\./,$file)[-1];
			    print $output;
			    closedir DIR;
			    exit 0;
			}
		    }
		}
	    }
	    print 0;
            closedir DIR;
	    exit 0;
	}


	if ($command eq "clean_recovery_files") {
	    #remove non-in-use recovery/layout files for given uid, gid
	    my $uid=$ARGV[1];
	    my $gid=$ARGV[2];
	    my $exename=$ARGV[3];
            opendir DIR,"$tmpdir";

	    chdir $tmpdir;

	    while (my $file=readdir(DIR)) {
		if ($file=~/^recovery\.$uid\.$gid\.(.*)/ || $file=~/^layout\.$uid\.$gid\.(.*)/ || $file=~/^layout_numbering\.$uid\.$gid\.(.*)/) {
		    my $exe=`readlink -n /proc/$1/exe`;
		    my $short_exe=&my_basename($exe);
		    unless ($short_exe eq $exename) {
			`/bin/rm -f $file 2>/dev/null`;
		    }
		}
	    }
            closedir DIR;
	    exit 0;
	}


        if ($command eq "get_next_in_set") {
            # this is a special function for lives-exe. It will look for
            # clips on the disk that have the marker file "set.$name"
	    # only used now for pre 0.9.6 versions

            $last=$ARGV[1];
            $setname=$ARGV[2];
            $pid=$ARGV[3];

            opendir DIR,"$tmpdir";
	    @allfiles=readdir(DIR);
            closedir DIR;

            foreach my $subdir (@allfiles) {
		if (-f "$tmpdir/$subdir/set.$setname") {
                    if ($last eq "none") {
                        $found=$subdir;
                        last;
                    }
                    if ($last eq $subdir) {
                        $last="none";
                    }
                }
	    }

	    if ($found eq "") {
                $found="none";
            }

            $infofile="$tmpdir/.info.$pid";
            `sync;sync;sync`;

            if (-d $tmpdir) {
                open OUT,"> $infofile";
                print OUT $found;
                close OUT;
            }
            exit 0;
        }


	if ($command eq "cleanup"||$command eq "weed") {
	    chdir $tmpdir or die "Couldn't cd to ".$tmpdir."\n";
	    print "Cleaning up temporary space for $GUI_NAME.\n";
	    if ($command eq "cleanup") {
		`/bin/rm -f /tmp/.smogval*`;
		`/bin/rm -rf *`;
		`/bin/rm -f .*`;
	    }
	    else {
		$new_temp=$ARGV[1];
		unless ($new_temp eq "") {
		    # here is where we create a new temp directory
		    unless (-d $new_temp||(mkdir $new_temp,0777)) {
			print "Smogrify: Unable to create new directory $new_temp!\n";
			exit 1;
		    }
		    print "Smogrify: moving sets from $tmpdir to $new_temp\n";
		}
		else {
		    print "Smogrify: Leaving sets intact.\n";
		}
		&weed;
	    }
	    exit 0;
	}
	
	if (substr($command,0,7) eq "fxinit_") {
	    # call onchange_init
	    $command=substr($command,7);
	    $handle=$ARGV[1];

	    $dir=$ARGV[2];

            $width=$ARGV[3];
            $height=$ARGV[4];

	    $plugin_name="$dir/$command";
	    shift; shift; shift; shift;

	    $curtmpdir="$tmpdir/$handle";

	    $ARGV[0]="onchange_init";
	    require("$plugin_name");
	    exit 0;
	}



	if ($command eq "count_frames") {
	    $img_ext=".".$ARGV[2];
	    print &count_frames;
	    exit 0;
	}


	if ($command eq "get_proj_set") {
	    my $proj_file=$ARGV[1];
	    my $out=`tar --exclude=*/* -tzf $proj_file`;
	    unless ($out=~/\/$/) {
		exit 1;
	    }
	    chomp $out;
	    chop $out;
	    print $out;

	    exit 0;
	}

        if ($command eq "mv_pre") {
	    $handle=$ARGV[1];
	    $curtmpdir="$tmpdir/$handle";
            $statusfile=$curtmpdir."/.status";
	    unlink "$curtmpdir/pause";
	    $start=$ARGV[2];
	    $end=$ARGV[3];
	    $img_ext=".".$ARGV[4];
	    &mv_pre;
	    &sig_complete;
	    exit 0;
	}



	if ($command eq "clear_symlinks") {
	    $handle=$ARGV[1];
	    &clear_symlinks;
	    exit 0;
	}



    
####################################################################    
    # run the rest in background
    if ($background==1) {
	if (fork()) {
	    exit 0;
	}
    }
####################################################################
    umask $umask;

    if (!caller&&(!defined($ARGV[1]) || $ARGV[1] eq "")) {
	&usage;
	exit 1;
    }

    $handle=$ARGV[1];

    $curtmpdir="$tmpdir/$handle";
    $statusfile=$curtmpdir."/.status";

    if ($command eq "play"||$command eq "play_opening_preview") {
	$pidfile=$curtmpdir."/.pidpb";
    }
    else {
	$pidfile=$curtmpdir."/.pid";
    }

    if ($command eq "play_opening_preview") {
	# play_opening_preview is exactly like play
	# except our audio filename is different
	$opening_preview=1;
	$command="play";
    }

	unless ($command eq "keep"||$command eq "close") {
	    # tell the world our pid
	    &sig_pid;
	}


    if ($command eq "play") {

	$endian=&get_endian;

	$fps=$ARGV[2];
	if ($fps==0) {
	    $fps=&rc_get("default_fps");
	}

	$start=$ARGV[3];
	$end=$ARGV[4];

	$fs=" ";
	if (defined $ARGV[5]) {
	    if ($ARGV[5]!="0") {
		$fs=" -fs ";
		}
	}
	$loop=0;
	if ($ARGV[6]!=0) {
	    $loop=$ARGV[6];
	}
	$wid=" ";
	if (defined $ARGV[7]) {
	    if ($ARGV[7]!=0) {
		$wid=" -wid ".$ARGV[7]." ";
	    }
	}
	if (!defined $ARGV[8]||$ARGV[8]==0||!($fs eq " ")) {
	    $width="";
	}
	else {
	    $hsize=$ARGV[8];
	    $width="-x $hsize ";
	}
	if (!defined $ARGV[9]||$ARGV[9]==0||!($fs eq " ")) {
	    $height="";
	}
	else {
	    $vsize=$ARGV[9];
	    $height="-y $vsize ";
	}
	if (!defined $ARGV[10]||$ARGV[10]==0) {
	    $arate=44100;
	}
	else {
	    $arate=$ARGV[10];
	}
	if (!defined $ARGV[11]||$ARGV[11]==0) {
	    $achans=2;
	}
	else {
	    $achans=$ARGV[11];
	}

	if (!defined $ARGV[12]||$ARGV[12]==0) {
	    $asamps=2;
	    $stype="w";
	}
	else {
	    $asamps=$ARGV[12];
	    if ($asamps>7) {
		$asamps/=8;
	    }
	}
	if (!defined $ARGV[13]) {
	    $signed=1;
	}
	else {
	    $signed=$ARGV[13];
	}

	if (!defined $ARGV[14]) {
	    $aendian=$endian;
	}
	else {
	    $aendian=$ARGV[14];
	}

	if (defined($opening_preview)) {
	    $aformat=".raw";
	    $audiofile=$curtmpdir."/audiodump.pcm";
	}
	else {
	    $aformat=".raw";
	    $audiofile=$curtmpdir."/audio";
	}


	$audio_player=&rc_get("audio_player");

	if (-f $audiofile && $arate) {

	    $audio_start=($start-1)/$fps;
	    $audio_end=$end/$fps;

	    $mute="";
	    if ($arate<0) {
		$mute=" -ao null  ";
		$arate=-$arate;
		if ($audio_player eq "sox") {
		    $mute=" -v 0 ";
		}
	    }
	    
	    $audio_play_command=&rc_get("audio_play_command");

	    if ($audio_player eq "sox") {
		$audio_effect=&rc_get("audio_effect");
		$trimcom=" trim $audio_start";

		if (($audio_end>$audio_start)&&$end>0) {
		    $trimcom .= " ".($audio_end-$audio_start);
		}
		else {
		    $trimcom .=" 10000000";
		}

		if ($signed==1) {
		    $signed="s";
		}
		else {
		    $signed="u";
		}

		if ($aendian==$endian) {
		    $aendian="";
		}
		else {
		    $aendian="-x";
		}
		
		if ($audio_effect eq "flanger1") {
		    $audio_effect="flanger 0.6 0.87 3.0 0.9 0.5 -s";
		}
		elsif ($audio_effect eq "echo1") {
		    $audio_effect="echo 0.8 0.9 1000.0 0.3";
		}
		elsif ($audio_effect eq "chorus1") {
		    $audio_effect="chorus 0.6 0.9 50.0 0.4 0.25 2.0 -t 60.0  0.32  0.4 1.3 -s";
		}
		elsif ($audio_effect eq "reverb1") {
		    $audio_effect="reverb 1.0 600.0 180.0 200.0";
		}
		elsif ($audio_effect eq "phaser1") {
		    $audio_effect="phaser 0.89 0.85 1.0 0.24 2.0 -t";
		}
		else {
		    $audio_effect="";
		}
		$sox_version=&get_sox_version;

		if ($sox_version<13) {
		    if ($asamps==1) {
			$stype="b";
		    }
		    elsif ($asamps==2) {
			$stype="w";
		    }
		    $aformat=".".$signed.$stype;
		    $syscom2="$audio_play_command $mute -c $achans -r $arate -$signed $aendian -t $aformat -$stype $audiofile $trimcom $audio_effect";
		}
		else {
		    $syscom2="$audio_play_command $mute -c $achans -r $arate -$signed $aendian -t $aformat -$asamps $audiofile $trimcom $audio_effect";
		}
	    } else {
		# mplayer seemingly has no easy way of playing unsigned or wrong endian
		$syscom2="$audio_play_command -demuxer rawaudio -rawaudio rate=$arate :channels=$achans:samplesize=$asamps $mute $audiofile -ss ".($audio_start-1);
	    }
	}
	
	$showed_err=0;

	do {
	    if (! -d "$curtmpdir" || -f "$curtmpdir/.stoploop" || ! -f $audiofile) {
		$loop=0;
	    }
	    else {
		$syscom3=$syscom2.">/dev/null 2>&1";
		$retval=system($syscom3);
		if ($retval>255) {
		    unless ($showed_err) {
			print STDERR "Error playing audio !\n";
			print STDERR "Failed command was: $syscom2\n";
			system($syscom2);
			$showed_err=1;
		    }
		}
	    }
	} while ($loop);
	&sig_complete_audio;

	unlink "$curtmpdir/.stoploop";

	exit 0;
    }


	if ($command eq "open") {
	unlink "$curtmpdir/pause";

	$file=$ARGV[2];
	$ss="";

	$withsound=$ARGV[3];

	if (defined($ARGV[4])) {
	    $img_ext=".".$ARGV[4];
	}
		
	if (defined($ARGV[5]) && $ARGV[5] > 0) {
	    $ss=" -ss $ARGV[5] ";
	}
	$frames="";
	if (defined($ARGV[6]) && $ARGV[6] > 0 ) {
	    $ARGV[6]++;  # cf below, we remove 1st frame
	    $frames=" -frames $ARGV[6] ";
	}
	$extra_params=$ARGV[7];
	$band="";
	if ($extra_params eq "nobandwidth") {
	    $extra_params="";
	}
	else {
	    if ($extra_params eq "sendbandwidth") {
		$bandwidth=&rc_get("dl_bandwidth_K");
		if ($bandwidth eq "") {
		    $bandwidth=64;
		}
		$band="-bandwidth $bandwidth"."000";
		$extra_params="";
	    }
	}
	$compression=&rc_get("open_compression_percent");
	if ($compression eq "") {
	    $compression=15;
	}

	chdir $curtmpdir;

	# let get_file_info set this
	#$mplay_command=&rc_get("video_open_command");

	# process video

	# 3 other files we will use
	$curtmpfile=".temp";
	$audio_out="audio";
	$audio_in="audiodump.pcm";

	if ($img_ext eq ".png") {
	    $compression=int($compression/10.001)
	}
	else {
	    $quality=int(100-$compression);
	}

	$xframes=$frames;

	my $wavhead=":nowaveheader";

	if ($file=~/:\/\//) {
	    $is_remote=2;
	    #$wavhead=""; # need wav header, as user will probably finish by
	                 # quitting, thus we won't send full info
	}
	&get_file_info;

	if ($type eq "jpeg" || $type eq "png") {
	    $count=$frames;
	}
	else {
	    $frames=$xframes;

	    if ($achans eq "" || $achans eq "0") {
		$channs="";
	    }
	    else {
		$channs="-channels $achans";
	    }
	    
	    if ($withsound eq "0") {
             #video only
		if ($img_ext eq ".jpg") {
		    $syscom=$mplay_command . " -quiet $band -osdlevel 0 -vo jpeg:quality=$quality -fps 100000 $ss $frames -noframedrop -ao null \"$file\" $extra_params </dev/null";
		}
		else {
		    $syscom=$mplay_command . " -quiet $band -osdlevel 0 -vo png:z=$compression:alpha -fps 100000 $ss $frames -noframedrop -ao null \"$file\" $extra_params </dev/null";
		}
	    }
	    elsif ($withsound eq "1") {
             #video and audio 
		if ($img_ext eq ".jpg") {
		    $syscom=$mplay_command . " -quiet $band -osdlevel 0 -vo jpeg:quality=$quality $ss -noframedrop $frames -ao pcm:fast$wavhead $channs -mc 0  \"$file\" $extra_params </dev/null";
		}
		else {
		    $syscom=$mplay_command . " -quiet $band -osdlevel 0 -vo png:z=$compression:alpha $ss -noframedrop $frames -ao pcm:fast$wavhead $channs -mc 0  \"$file\" $extra_params </dev/null";
		}
            }
            else {
             #audio only 
		$syscom=$mplay_command . " -quiet $band -vo null $ss $frames -ao pcm:fast$wavhead $channs -mc 0 \"$file\" $extra_params </dev/null";
            }
	    
	    if (defined($DEBUG_OPEN)) {
		print STDERR "open command for $handle is: $syscom\n";
	    }
	    
	    $syscom2=$syscom." >$curtmpfile 2>/dev/null";

	    &sig_progress(0);

	    system($syscom2);
	    
            if (!-f $curtmpfile) {
              exit 1;
            }


	    @info=split /  /, `grep VIDEO: $curtmpfile`;
	    @info2=split / /, `grep AUDIO: $curtmpfile`;
	    
	    unlink $curtmpfile;
	    #$type=$info[1];
	    
	    $size=$info[2];
	    $hsize=(split /x/,$size)[0];
	    $vsize=(split /x/,$size)[1];
	    $bpp=$info[3];
	    chomp($bpp);
	    
	    $fps=(split / /,$info[4])[0];
	    
	    $arate=$info2[1];
	    $achans=$info2[3];

	    if (! -d $curtmpdir) {
		#curtmpdir can be removed by cancel
		exit 1;
	    }
	    
	    # double check number of frames
	    $count=&count_frames;

	}

	# if the last frame has zero size, delete it
	if ($count>0) {
	    $name=&mkname($count);
	    while (-f "$name$img_ext" && -z "$name$img_ext" && $count > 1) {
		unlink "$name$img_ext";
		$count--;
	    }
	    # double check image size
	    $name=&mkname(1);
	    $imresact="none";
	    &get_image_size("$name$img_ext");
	}

	if (-f $audio_in) {
	    rename $audio_in,$audio_out;
            $af_size = -s $audio_out; 
	}

	if ($img_ext eq ".png" || $type eq "png") {
	    $bpp=32;
	}

	if ($count==0||$type eq "jpeg"||$type eq "png"||$type eq "Audio") {
	    # we could have audio or images
	    if (-f $audio_out) {
		# just in case...
		$type="Audio";
	    }
	    if (! -d $curtmpdir) {
		#curtmpdir can be removed by cancel
		exit 1;
	    }

	    if ($af_size>0||$count>0) {
		&sig_complete($handle,$count,$type,$hsize,$vsize,$bpp,$fps,$f_size,$arate,$achans,$asamps,$signed,$endian,$af_size,$title,$author,$comment);
		exit 0;
	    }
	    # should have audio then
	    if (!($type eq "Audio")) {
		if (!defined($DEBUG_OPEN)&&$withsound>=0) {
		    print STDERR "\nFailed to open file - I tried:\n\n $syscom\n";
		    print STDERR "\nMaybe you are missing a library in mplayer (or it is not a valid media file) ?\n";
		}
		&sig_error("This does not appear to be a valid video or image file","$GUI_NAME was unable to open it.","","Check the terminal window for more details.");
		
	    }
	}

	# mplayer seems to sometimes output one extra frame for jpg
	if (defined($MPLAYER_EXTRA_OPEN_FRAME_BUG)&&($count==$xframes+1)&&(($frames eq "")||(!($frames eq "") && ($count<$ARGV[4])||($ARGV[3]==0)))) {
	    $name=&mkname($count);
	    unlink "$name$img_ext";
	    $count--;
	}

	unless ($frames eq "") {
	    $tfps=$fps;
	    if ($fps<1) {
		$tfps=1;
	    }
	    if ($ARGV[3]>=(1/$tfps)) {
		# if we opened a selection, mplayer wrongly outputs frame 1, 
		# so we usually need to delete it

		#TODO ** - check if this is still the case

		for ($i=2;$i<=$count;$i++) {
		    $from=&mkname($i);
		    $to=&mkname($i-1);
		    rename "$from$img_ext", "$to$img_ext";
		}
		$count--;
	    }
	}

	unless (!defined($MPLAYER_SEL_AUDIO_SYNCH_BUG)||$ss eq ""||$achans==0) {
	    # try as best we can to sync sound and video for a selection
	    $audio_out=&clip_audio(0.5,1000000.);
	    rename $audio_out,"audio";
	    $audio_out="audio";
	}

	$af_size= -s $audio_out;
	if (-d $curtmpdir) {
	    &sig_complete($handle,$count,$type,$hsize,$vsize,$bpp,$fps,$f_size,$arate,$achans,$asamps,$signed,$endian,$af_size,$title,$author,$comment);
	}
	exit 0;
    }

    if ($command eq "get_details") {
	$handle=$ARGV[1];
	$curtmpdir="$tmpdir/$handle";
	$statusfile="$curtmpdir/.status";

	#attempt to get file details
	$file=$ARGV[2];
	$only_first=1;

	$img_ext=".".$ARGV[3];

	if (defined($ARGV[4])) {
	    $is_remote=$ARGV[4];
	}
	if (defined($ARGV[5])) {
	    $is_audio=$ARGV[5];
	}
	&get_file_info;
	&sig_complete($handle,$count,$type,$hsize,$vsize,$bpp,$fps,$f_size,$arate,$achans,$asamps,$signed,$endian,$af_size,$title,$author,$comment);
	exit 0;
    }



        if ($command eq "open_tv_card") {
	    $chanstr=$ARGV[2];
	    $devstr=$ARGV[3];
	    $fifofile=$ARGV[4];

	    if (defined($ARGV[5])&&defined($ARGV[6])) {
		$sizestr="width=$ARGV[5] height=$ARGV[6]";
	    }

	    if (defined($ARGV[7])) {
		$fpsstr="fps=$ARGV[7]";
	    }

	    if (defined($ARGV[8])) {
		$driverstr="driver=$ARGV[8]";
	    }

	    if (defined($ARGV[9])) {
		$outfmt="outfmt=$ARGV[9]";
	    }

	    system("mplayer -really-quiet tv://$chanstr -tv device=$devstr $driverstr $sizestr $outfmt $fpsstr -vo yuv4mpeg:file=$fifofile >/dev/null 2>&1");
	    exit 0;
	}



        if ($command eq "open_fw_card") {
	    $cardno=$ARGV[2];
	    $cache=$ARGV[3];
	    $fifofile=$ARGV[4];

	    system("dvgrab -noavc -card $cardno - 2>/dev/null| mplayer - -really-quiet -cache $cache -demuxer lavf -vo yuv4mpeg:file=$fifofile >/dev/null 2>&1");
	    exit 0;
	}






	if ($command eq "close") {
	    if (defined(open IN,"< $pidfile")) {
		close IN;
		# cancel any processing
		system("smogrify stopsubsub $handle");
	    }
	    
	    if (chdir $curtmpdir) {
		unlink <* .*>;
		chdir $tmpdir;
		rmdir $curtmpdir;
	    }
	    exit 0;
	}
    

	
	if ($command eq "save") {
	    $get_rfx=0;

	    if ($handle eq "get_rfx") {
		$get_rfx=1;
		shift(@ARGV);
		$handle=$ARGV[1];

		$curtmpdir="$tmpdir/$handle";
		$statusfile=$curtmpdir."/.status";
		$pidfile=$curtmpdir."/.pid";
	    }

	    unlink "$curtmpdir/pause";
	    chdir $curtmpdir;

	    $plugin=$ARGV[2];

	    $fps=$ARGV[3];
	    $nfile=$ARGV[4];

	    # check the file is writable
	    unless ($nfile eq ""||&is_writeable($nfile)) {
		&sig_error("Unable to open output file !","$GUI_NAME could not write to $nfile.");
	    }

	    $start=$ARGV[5];
	    $is_linked=0;

	    #create symlinks in /tmp (for dynebolic)
	    $linksdir="/tmp/lives-symlinks/$handle/";

	    if ($start==-1) {
		# special value which tells us we are dealing with symlinks
		$start=1;
		$is_linked=1;
	    }

	    $end=$ARGV[6];
	    $arate=$ARGV[7];
	    $achans=$ARGV[8];
	    $asamps=$ARGV[9];
	    if (defined($ARGV[10])) {
		$ssigned=$ARGV[10];
	    }
	    
	    else {
		$ssigned=1;
		if ($asamps==8) {
		    $ssigned=0;
		}
	    }
	    if ($ssigned==1) {
		$asigned="-s";
	    }
	    else {
		$asigned="-u";
	    }
	    
	    # assume endianness matches machine endianness
	    $aendian=&get_endian;

	    if (defined($ARGV[11])) {
		$aud_start=$ARGV[11];
	    }
	    else {
		$aud_start=($start-1.)/($fps*1.);
	    }
	    if (defined($ARGV[12])) {
		$aud_end=$ARGV[12];
	    }
	    else {
		$aud_end=($end*1.)/($fps*1.);
	    }

	    $img_ext=&get_img_ext($curtmpdir,$start);

	    # get image size ($hsize x $vsize)
	    $imresact="none";
	    my $firstframe=&mkname($start);
	    &get_image_size("$firstframe$img_ext");

	    $otype=&rc_get("output_type");

	    $encoder=&rc_get("encoder");

	    $DEBUG_ENCODERS=1;

	    $audiofile="";

	    if ($get_rfx==0) {

		unlink "audiodump.wav";

		$areq=&get_form_request($plugin);

		#prepare audio stream if requested
		if (-f "$curtmpdir/audio" && $arate>0) {

		    $origaudio=$audiofile=$audio_in="$curtmpdir/audio";
		    if ($areq&1||$aud_start!=0.) {
			
			# encode sound up to the next nearest second
			# seems to be the norm...
			$aud_length=($aud_end-$aud_start);
			$aud_length=int($aud_length+1.0);
			$aud_end=$aud_start+$aud_length;
			
			# clip the (raw) audio

			$audiofile=$audio_in=&clip_audio($aud_start,$aud_end);
			
			#pad to end with silence
			$desired_length=$aud_length*$arate*$achans*$asamps/8;
			&append_silence($desired_length,$asamps,$achans,$ssigned,$aendian,$audiofile);
			
			if ($aud_start!=0.&&!($areq&1)) {
			    if (&rc_get("conserve_space") eq "true") {
				`/bin/rm -f $origaudio`;
			    }
			    else {
				rename "$origaudio","$origaudio.origbak";
			    }
			    rename "$curtmpdir/$audiofile","$origaudio";
			    $audio_file=$audio_in=$origaudio;
			}
		    }
		    if ($areq&2) { 
			# convert raw audio to wav
			$audio_out=$curtmpdir . "/audiodump.wav";
			&convert_audio_to_wav;
			unlink $audio_in;
			$audiofile=$audio_out;
		    }
		}
		
		if ($areq&4) {
	
		    if ($start>1) {
			# move the selection down so that frames start at 1
			# note, LiVES never uses this any more, 
			# instead it first calls link_frames, and possibly sets $start to -1
			# (see above)

			if (-d $linksdir) {
			    system("/bin/rm -rf $linksdir");
			}
		    
			system("/bin/mkdir -p $linksdir");
			system ("/bin/chmod -R 777 $linksdir");

			for ($i=1;$i<=($end-$start+1);$i++) {
			    $name=&mkname($i);
			    $from=&mkname($i+$start-1);
			    if (-f "$curtmpdir$from$img_ext") {
				system ("/bin/ln $curtmpdir/$from$img_ext $linksdir$name$img_ext");
			    }
			}
			if (-f $audiofile) {
			    my $xaudiofile=(split(/\//,$audiofile))[-1];
			    if (! -f "$linksdir$xaudiofile") {
				system("/bin/ln $audiofile $linksdir$xaudiofile");
			    }
			}
			$is_linked=1;
		    }
		}
		
		if ($is_linked==1) {
		    chdir $linksdir;
		}

	    }


	    unless ($plugin eq "") {
		#non-perl
		$atype=&rc_get("encoder_acodec");
		$fields="$fps \"$nfile\" $start $end $img_ext $otype $atype $hsize $vsize";
		$fields.=" $DEBUG_ENCODERS";
		$fields.=" $arate $achans $asamps $ssigned";
		if ($get_rfx==0) {
		    $fields.=@ARGV[13..$#ARGV];
		    system("$plugin encode $fields");
		}
		else {
		    system("$plugin get_rfx $fields");
		}

		&sig_complete;
		exit 0;
	    }


	    if (-f ".comment") {
		open IN,"< .comment";
		read IN,$string,1040;
		close IN;
		unlink ".comment";
	    }
	    @tmp=split(/\|\|\%/,$string);
	    $title=$tmp[0];
	    $author=$tmp[1];
	    $comment=$tmp[2];
	    chomp($comment);

	    if ($get_rfx==0) {
		$command="encode";
	    }
	    else {
		$command="get_rfx";
	    }
	    return 1;
	    exit 0; # just in case
	}


	if ($command eq "link_frames") {
	unlink "$curtmpdir/pause";
	    chdir $curtmpdir;

	    $start=$ARGV[2];
	    $end=$ARGV[3];
	
	    $astart=$ARGV[4];
	    $aend=$ARGV[5];

	    $arate=$ARGV[6];
	    $achans=$ARGV[7];
	    $asamps=$ARGV[8];
	    $asigned=$ARGV[9];
	    $aendian=$ARGV[10];

	    $from_handle=$ARGV[11];

	    my $i;
	    my $audiofile="audio";

	    if ($from_handle eq "") {
		#create symlinks in /tmp for dynebolic
		$linksdir="/tmp/lives-symlinks/$handle/";

		if (-d $linksdir) {
		    system("/bin/rm -rf $linksdir");
		}

		system("/bin/mkdir -p $linksdir");
		system ("/bin/chmod -R 777 $linksdir");
	    }
	    else {
		$linksdir=$curtmpdir;
		$handle=$from_handle;
		$curtmpdir="$tmpdir/$handle/";
	    }

	
	# copy a slice of the audio file into our links dir
	# this allows us to resample it
	# and also aligns the start of audio with new frame 1

	unless ($aend==0.) {

	    my $ocurtmpdir=$curtmpdir;
	    my $ofrom_handle=$from_handle;
	    my $ostart=$start;
	    my $oend=$end;

	    $start=$astart;
	    $end=$aend;
	    $where=0.;
	    $from_handle=$handle;
	    $curtmpdir=$linksdir;

	    &insert_audio($asamps,$achans,$asigned,$aendian);
	
	    $curtmpdir=$ocurtmpdir;
	    $from_handle=$ofrom_handle;
	    $start=$ostart;
	    $end=$oend;

	  }

	$img_ext=&get_img_ext($curtmpdir,$start);

	    for ($i=1;$i<=($end-$start+1);$i++) {
		$name=&mkname($i);
		$from=&mkname($i+$start-1);
		if (-f "$curtmpdir/$from$img_ext") {
		    system ("/bin/ln $curtmpdir/$from$img_ext $linksdir/$name$img_ext");

		}
		&sig_progress($i);
	    }

 	    unless ($from_handle eq "") {
		$curtmpdir=$linksdir;
	    }

	    &sig_complete;
	    exit 0;
    }


	if ($command eq "resize_all") {
	    unlink "$curtmpdir/pause";
	    chdir $curtmpdir;
	    $end=$ARGV[2];

	    my $width=$ARGV[3];
	    my $height=$ARGV[4];

	    $img_ext=".".$ARGV[5];

	    $resize_ext=".mgk";

	    for ($i=1;$i<=$end;$i++) {
		$name=&mkname($i);
		&resize_frame($name,$width,$height);
		&sig_progress($i);
	    }
	    $start=1;
	    &mv_mgk;
	    &sig_complete;
	    exit 0;
	}

    if ($command eq "backup") {
	$withaudio=$ARGV[2];
	$start=$ARGV[3];
	$end=$ARGV[4];

	if ($withaudio==0) {
	    $audio="";
	}
	else {
	    $audio="audio";
	}

	$nfile=$ARGV[5];

	unlink "$curtmpdir/pause";
	chdir $curtmpdir;

	# check the file is writable
	unless (&is_writeable($nfile)) {
	    &sig_error("Unable to open output file !","$GUI_NAME could not write to $nfile.");
	}

	unlink <*.tar>;
	system ("tar -cf header.tar $audio header* extended* event.* 2>/dev/null");

	$img_ext=&get_img_ext($curtmpdir,$start);

	if ($start>0) {
	    # we have to add frames 100 at a time, otherwise tar complains about 'too many parameters'
	    $oend=$end;
	    $nexthundred=int($start/100)+1;
	    if ($end>$nexthundred*100-1) {
		$end=$nexthundred*100-1;
	    }
	    
	    $tarcount=1;
	    $tarname=&mkname($tarcount).".tar";
	    
	    for ($i=$start;$i<=$end;$i++) {
		$name=&mkname($i);
		system("tar -rf $tarname $name$img_ext");
		&sig_progress(int($start+($i-$start)/4));
	    }
	    
	    while (($nexthundred+1)*100<=$oend) {
		$end=$nexthundred*100;
		$len=length ($nexthundred);
		$name=substr("000000",$len) . $nexthundred . "*";
		$tarname=&mkname(++$tarcount).".tar";
		system("tar -cf $tarname $name$img_ext");
		$nexthundred++;
		&sig_progress(int($start+($end-$start)/4));
	    }
	    
	    $tarname=&mkname(++$tarcount).".tar";
	    
	    for ($i=$end;$i<=$oend;$i++) {
		$name=&mkname($i);
		system("tar -rf $tarname $name$img_ext 2>.tar_err");
		if (-f ".tar_err") {
		    open IN,"< .tar_err";
		    read IN,$tarerr,255;
		    close IN;
		    unless ($tarerr eq "") {
			&sig_err("Error creating new backup - temp dir may be full.",$tarerr);
			unlink <*.tar .tar_err>;
			exit 1;
		    }
		}
		&sig_progress($start+($i-$start));
	    }
	}
	system ("tar -czf \"$nfile\" *.tar 2>.tar_err");
	unlink <header.tar 0*.tar>;
	if (-f ".tar_err") {
	    open IN,"< .tar_err";
	    read IN,$tarerr,255;
	    close IN;
	    # TODO - check this, it is not working
	    unless ($tarerr eq "") {
		&sig_error("Error creating new backup.",$tarerr);
		unlink <*.tar .tar_err>;
		exit 1;
	    }
	}
	$size=-s "$nfile";
	&sig_complete($size);
	exit 0;
    }


    if ($command eq "restore") {
	$nfile=$ARGV[2];
	chdir $curtmpdir;

	system("tar -zxf \"$nfile\" 2>/dev/null");
	unless (-f "header.tar"||-f "header"||-f "header.lives") {
	    &sig_error("This does not appear to be a valid backup file","$GUI_NAME was unable to open it.");
	}
	system("for i in *.tar; do tar -xf \$i 2>/dev/null; /bin/rm -f \$i; done");
	&sig_complete;
	exit 0;
    }



    if ($command eq "reorder") {
	unlink "$curtmpdir/pause";

	$img_ext=".".$ARGV[2];

	if (!defined($ARGV[3])) {
	    $endian=&get_endian;
	}
	else {
	    $endian=$ARGV[3];
	}
	if (defined $ARGV[4]) {
	    $newwidth=$ARGV[4];
	}
	if (defined $ARGV[5]) {
	    $newheight=$ARGV[5];
	}
	if (defined $ARGV[6]) {
	    if ($ARGV[6]==1) {
		$leave_bak=1;
	    }
	}
	if (defined $ARGV[7]) {
	    $old_end=$ARGV[7];
	}

	$newframe=-1;
	$event_file="$curtmpdir/event.frames";
	$resize_ext=".tmp";
	chdir $curtmpdir;

	unless ($leave_bak==1) {
	    &clean_old;
	}

	if (defined(open IN,"< $event_file")) {
	    $fcount=1;
	    read IN,$val,4;
	    $pstart=&getint($val);
	    $count=$pstart;
	    
	    while ($newframe!=0) {
		read IN,$val,4;
		$newframe=&getint($val);
		if ($newframe>0) {
		    $from=&mkname($newframe);
		    if (-f "$curtmpdir/$from$img_ext") {
			$to=&mkname($count);

			if (defined $newwidth && defined $newheight && $newwidth*$newheight > 0) {
			    &resize_frame($from,$newwidth,$newheight);
			    unlink "$to.mgk";
			    rename "$from$resize_ext","$to.mgk";
			}
			else {
			    # we don't preview here...
			    unless ($from eq $to) {
				`/bin/cp $from$img_ext $to.mgk`;
			    }
			}
		    }

		    $count++;
		}
		&sig_progress($fcount++);
	    }
	    close IN;
	}
	
	else {
	    &sig_error;
	}

	$start=$pstart;
	$new_count=--$count;
	$end=$count;

	&mv_mgk;

	if ($end<$old_end) {
	    for ($i=$end+1;$i<=$old_end;$i++) {
		$name=&mkname($i);
		if (-f "$curtmpdir/$name$img_ext") {
		    unlink "$curtmpdir/$name.bak";
		    rename "$curtmpdir/$name$img_ext","$curtmpdir/$name.bak";
		}
	    }
	    &sig_progress($i);
	}

	&sig_complete($new_count);
	exit 0;
    }



    if ($command eq "deorder") {
	$start=$ARGV[2];
	$end=$ARGV[3];
	$frames=$ARGV[4];
	$img_ext=".".$ARGV[5];
	if (defined $ARGV[6]) {
	    $leave_bak=$ARGV[6];
	}
	else {
	    $leave_bak=0;
	}

	chdir $curtmpdir;

	$oend=$end;
	if ($end>$frames) {
	    $end=$frames;
	}

	&undo(!$leave_bak);

	for ($i=$frames+1;$i<=$oend;$i++) {
	    $name=&mkname($i);
	    if (!$leave_bak) {
		unlink "$curtmpdir/$name$img_ext";
	    }
	    else {
		rename "$curtmpdir/$name$img_ext","$curtmpdir/$name.mgk";
	    }
	}
	if (!$leave_bak) {
	    &clean_old;
	}
	&sig_complete;
	exit 0;
    }


    if ($command eq "cut") {
	unlink "$curtmpdir/pause";
	&clean_old;

	$start=$ARGV[2];
	$end=$ARGV[3];
	$cut_audio=$ARGV[4];
	$frames=$ARGV[5];
	$img_ext=".".$ARGV[6];
	&cut($start,$end);

	if ($cut_audio) {
	    $fps=$ARGV[7];
	    $arate=$ARGV[8];
	    $achans=$ARGV[9];
	    $asamps=$ARGV[10];
	    if ($arate*$asamps*$achans) {
		$start=($start-1)/$fps;
		$end=$end/$fps;
		&cut_audio;
	    }
	}
	&sig_complete;
	exit 0;
    }


	if ($command eq "delete_all") {
	    $frames=$ARGV[2];
	    if (! -d $curtmpdir) {
		&sig_complete;
		exit 1;
	    }
	    chdir $curtmpdir;
	    unlink <*>;
	    if ($GUI_NAME eq "LiVES") {
		# LiVES needs this to stop the progress dialog from flickering 
		sleep(1);
	    }
	    &sig_complete;
	    exit 0;
	}



    if ($command eq "reverse") {
	unlink "$curtmpdir/pause";
	$start=$ARGV[2];
	$end=$ARGV[3];
	$img_ext=".".$ARGV[4];
	&reverse;
	&sig_complete;
	exit 0;
    }


    if ($command eq "undo") {
	unlink "$curtmpdir/pause";

	$start=$ARGV[2];
	$end=$ARGV[3];
	$img_ext=".".$ARGV[4];
	&undo;
	&sig_complete;
	exit 0;
    }


    if ($command eq "redo") {
	unlink "$curtmpdir/pause";

	$start=$ARGV[2];
	$end=$ARGV[3];
	$img_ext=".".$ARGV[4];

	&mv_mgk(1);
	&sig_complete;
	exit 0;
    }


    if ($command eq "fs_preview") {
	$win=$ARGV[2];
	$hsize=$ARGV[3];
	$vsize=$ARGV[4];
	$start_time=$ARGV[5];
	$preview_frames=$ARGV[6];
	$file=$ARGV[7];
	$extra_params=$ARGV[8];
	$mplayer_command=&location("mplayer");

	system("$mplayer_command -quiet -x $hsize -y $vsize -wid $win -vo x11 -zoom -ss $start_time -frames $preview_frames \"$file\" $extra_params >/dev/null 2>&1 </dev/null");
	&sig_complete;
	exit 0;
    }

        if ($command eq "mv_mgk") {
	    unlink "$curtmpdir/pause";
	    $start=$ARGV[2];
	    $end=$ARGV[3];
	    $img_ext=".".$ARGV[4];
	    &mv_mgk;
	    &sig_complete;
	    exit 0;
	}



    if ($command eq "export_audio") {
	$audio_start=$ARGV[2];
	$audio_end=$ARGV[3];
	$arate=$ARGV[4];
	$achans=$ARGV[5];
	$asamps=$ARGV[6];
	$asigned=$ARGV[7];
	$nrate=$ARGV[8];
	$nfile=$ARGV[9];

	# check the file is writable
	unless (&is_writeable($nfile)) {
	    &sig_error("Unable to open output file !","$GUI_NAME could not write to $nfile.");
	}
	if ($asigned==1) {
	    $asigned="-s";
	}
	else {
	    $asigned="-u";
	}
	
	if ($audio_end>0.) {
	    $audio_in=&clip_audio($audio_start,$audio_end);
	}
	else {
	    $audio_in="$curtmpdir/audio";
	}
	# convert raw audio to wav
	$audio_out=$curtmpdir . "/audiodump.wav";
	&convert_audio_to_wav;
	if ($audio_end>0.) {
	    unlink $audio_in;
	}
  
	system("mv $audio_out \"$nfile\" >/dev/null 2>&1");
	system("chmod 644 \"$nfile\" >/dev/null 2>&1");

	&sig_complete;
	exit 0;
    }



    if ($command eq "append_audio") {
	# here we end up with (raw) 'audiodump', which will be renamed to 'audio' in commit_audio
	$endian=&get_endian;

	$type=$ARGV[2];
	$nrate=$ARGV[3];
	$nchans=$ARGV[4];
	$nsamps=$ARGV[5];
	$nsigned=$ARGV[6];
	$nendian=$ARGV[7];
	$file=$ARGV[8];
	$audio_in="audiodump.wav";

	chdir $curtmpdir;
	$audiofile="audio";

	if ($type eq "mp3") {
	    &mp3_open;
	}
	elsif ($type eq "ogg") {
	    &ogg_open;
	}
	elsif ($type eq "wav") {
	    &wav_open;
	}
	else {
	    &othera_open;
	}

	`sync;sync;sync`;

	unless (-f $audio_in) {
	    &sig_error("$GUI_NAME was not able to open the file","$file");
	}
	
	$audio_out="audio.new";
	&convert_audio_to_raw;
	unlink $audio_in;

	$audio_bak="audio.bak";

	# resample $audio_out (if required)
	unless ($arate==$nrate&&$achans==$nchans&&$asamps==$nsamps&&$nsigned==$signed&&$nendian==$endian) {
	    $audio_in=$audio_out;
	    $audio_out=$audio_bak;
	    &resample_audio;
	    unlink $audio_in;
	    rename $audio_out,$audio_in;
	    $audio_out=$audio_in;
	}

	system("cat audio $audio_out > audiodump");

	unlink $audio_out;
	$fsize=-s "audiodump";
	&sig_complete($fsize);
	exit 0;
    }


    if ($command eq "trim_audio") {
	$audio_start=$ARGV[2];
	$audio_end=$ARGV[3];
	$arate=$ARGV[4];
	$achans=$ARGV[5];
	$asamps=$ARGV[6];
	$asigned=$ARGV[7];
	$aendian=$ARGV[8];

	unless (&rc_get("conserve_space") eq "true") {
	    &backup_audio;
	}

	# $audio_from is the new clip
	$audio_from=&clip_audio($audio_start,$audio_end);
	unlink $audio_in;
	$where=$audio_start;
	$end=$audio_end-$audio_start;
	$start=0;
	# insert_audio will insert silence at start
	&insert_audio($asamps,$achans,$asigned,$aendian);
	unlink $audio_out;
	&append_silence(&align($audio_end*$arate*$align),$asamps,$achans,$asigned,$aendian);

	&sig_complete;
	exit 0;
    }


    if ($command eq "delete_audio") {
	$start=$ARGV[2];
	$end=$ARGV[3];
	$arate=$ARGV[4];
	$achans=$ARGV[5];
	$asamps=$ARGV[6];

	&cut_audio;

	&sig_complete;
	exit 0;
    }

    if ($command eq "resample_audio") {
	$arate=$ARGV[2];
	$achans=$ARGV[3];
	$asamps=$ARGV[4];
	$asigned=$ARGV[5];
	$aendian=$ARGV[6];


	$nrate=$ARGV[7];
	$nchans=$ARGV[8];
	$nsamps=$ARGV[9];
	$nsigned=$ARGV[10];
	$nendian=$ARGV[11];
	$audio_in="$curtmpdir/audio.bak";
	$audio_out="$curtmpdir/audio";

	if (defined($ARGV[12])) {
	    $stretch=$ARGV[12];
	    $audio_in="$curtmpdir/audio.orig";
	}

	unlink $audio_in;
	rename $audio_out,$audio_in;

	`sync;sync;sync`;

	&resample_audio;

	if (&rc_get("conserve_space") eq "true" && (-s $audio_out)) {
	    unlink $audio_in;
	}

	&sig_complete;
	exit 0;
    }



    if ($command eq "get_window_id") {
	system("xwininfo > $curtmpdir/tmpinfo");

	system("grep \"Window id:\" $curtmpdir/tmpinfo > $curtmpdir/tmpinfo2");
	if (defined(open IN,"< $curtmpdir/tmpinfo2")) {
	    read IN,$win_id,128;
	    close IN;
	}
	@wid=split(/ /,$win_id);
	$win_id=hex($wid[3]);
	chomp($win_id);

	system("grep \"Width:\" $curtmpdir/tmpinfo > $curtmpdir/tmpinfo2");
	if (defined(open IN,"< $curtmpdir/tmpinfo2")) {
	    read IN,$width,128;
	    close IN;
	}
	@widths=split(/Width: /,$width);
	$width=$widths[1];
	chomp($width);

	system("grep \"Height:\" $curtmpdir/tmpinfo > $curtmpdir/tmpinfo2");
	if (defined(open IN,"< $curtmpdir/tmpinfo2")) {
	    read IN,$height,128;
	    close IN;
	}
	@heights=split(/Height: /,$height);
	$height=$heights[1];
	chomp($height);

	system("grep \"Depth:\" $curtmpdir/tmpinfo > $curtmpdir/tmpinfo2");
	if (defined(open IN,"< $curtmpdir/tmpinfo2")) {
	    read IN,$bpp,128;
	    close IN;
	}
	@bpps=split(/Depth: /,$bpp);
	$bpp=$bpps[1];
	chomp($bpp);

	unlink "$curtmpdir/tmpinfo";
	unlink "$curtmpdir/tmpinfo2";

	&sig_complete($win_id,$width,$height,$bpp);
	exit 0;
    }


    if ($command eq "fill_and_redo_frames") {
	# remove any gaps in the play images
	unlink "$curtmpdir/pause";
	$end=$ARGV[2];
	$width=$ARGV[3];
	$height=$ARGV[4];
	$img_ext=".".$ARGV[5];
	$has_audio=0;
	$fps=$ARGV[6];
	$arate=$ARGV[7];
	$achans=$ARGV[8];
	$asamps=$ARGV[9];
	$asigned=$ARGV[10];
	$aendian=$ARGV[11];

	if ($achans>0) {
	    $has_audio=1;
	}

	&fill_and_redo_frames;
	
	if ($has_audio) {
	    $aud_end=($end/$fps)*$achans*$arate*($asamps/8);
	    $audio_in="$curtmpdir/audio";
	    $audsize=-s $audio_in;
	    if ($audsize > $aud_end) {
		$audio_out=&clip_audio(0.,$end/$fps);
		unlink $audio_in;
		rename $audio_out,$audio_in;
	    }
	    elsif ($audsize<$aud_end) {
		$audio_out="$curtmpdir/audio.bak";
		rename $audio_in,$audio_out;
		&append_silence($aud_end-$audsize,$asamps,$achans,$asigned,$aendian,$audio_in);
		`cat $audio_out>>$audio_in`;
		unlink $audio_out;
	    }
	}

	&sig_complete;
	exit 0;
    }


    if ($command eq "commit_audio") {
	# commit the audio file in either audiodump or audiodump.wav as new audio file
	chdir $curtmpdir;
	$audio_out="audio";
	$audio_bak="audio.bak";

	my $gotit=0;

	$file=$audio_in="audiodump.wav";

	my $f_size=-s $audio_in;
	if ($f_size>0) {
	    # wav format
	    if (&rc_get("conserve_space") eq "true") {
		unlink $audio_out;
	    }
	    else {
		if (-f $audio_out) {
		    rename $audio_out,$audio_bak;
		}
		else {
		    `touch $audio_bak`;
		}
	    }
	    $is_audio=TRUE;
	    &get_file_info;
	    &convert_audio_to_raw;
	}
	else {
	    $audio_in="audiodump";
	    if (! -f $audio_in) {
		$audio_in="audiodump.pcm";
	    }
	    else {
		$gotit=1;
	    }
	    if ($gotit || -f $audio_in) {
		# raw format
		if (&rc_get("conserve_space") eq "true") {
		    unlink $audio_out;
		}
		else {
		    if (-f $audio_out) {
			rename $audio_out,$audio_bak;
		    }
		    else {
			`touch $audio_bak`;
		    }
		}
		rename $audio_in,$audio_out;
		# dummy values, the GUI should know these
		$arate=$achans=$asamps=0;
		$signed=$endian=1;
	    }
	    else {
		&sig_error("$GUI_NAME audio error.");
	    }
	}
	unlink <audiodump.*>;

	$f_size=-s $audio_out;
	&sig_complete($arate,$achans,$asamps,$signed,$endian,$f_size);
	exit 0;
    }

    if ($command eq "cancel_audio") {
	# remove the audio file in audiodump/audiodump.wav
	# plus any audio.new files (e.g. from append audio)

	chdir $curtmpdir;
	unlink <audiodump* audio.new>;

	&sig_complete;
	exit 0;
    }


    if ($command eq "cdopen") {

	$cdda2wav_command=&location("cdda2wav");
	if ($cdda2wav_command eq "") {
	    &sig_error("cdda2wav is required for this function.","Please install it first.");
	}

	$cdplay_device=&rc_get("cdplay_device");
	if ($cdplay_device eq "") {
	    &sig_error("You must set the CD device first in Preferences.");
	}

	$track=$ARGV[2];

	$audiofile=$curtmpdir."/audiodump.wav";
	if (-f $audiofile) {
	    unlink $audiofile;
	}

	system("$cdda2wav_command -q -x -D $cdplay_device -t $track $audiofile >/dev/null 2>&1");
	$f_size=-s $audiofile;
	# the '-x' option will force these
	$arate=44100;
	$achans=2;
	$asamps=16;
	$aendian=&get_endian;
	$asigned=1;
	if ($asamps==8) {
	    $asigned=0;
	}
	&sig_complete($arate,$achans,$asamps,$asigned,$aendian,$f_size);
	exit 0;
    }


    if ($command eq "audioopen") {
	# TODO - allow front end to specify rate/channels, etc.

	$file=$ARGV[2];
	$audio_in=$curtmpdir."/audiodump.wav";

	$ext=&get_ext($file);
	if ($ext eq ".mp3") {
	    &mp3_open;
	}
	elsif ($ext eq ".ogg") {
	    &ogg_open;
	}
	elsif ($ext eq ".wav") {
	    &wav_open;
	}
	else {
	    &othera_open;
	}

	&sig_complete($arate,$achans,$asamps,$asigned,$aendian,$f_size);
	exit 0;
    }

    if ($command eq "xmmsrandom") {
	#messy, but it should work for now
	# TODO - compile list of all audio files, then pick one at random
	$trackstoplay=$ARGV[2];
	$descend=$ARGV[3];
	$minmeg=$ARGV[4];
	$maxmeg=$ARGV[5];
	$origdir=$dir=$ARGV[6];
	$meg=1024*1024;

	$xmms_command=&location("xmms");
	unless ($xmms_command eq "") {
	    $first=1;
	    $tracks=0;
	    # give up if we tried 200 files and didn't get an audio file
	    $giveup=200;

	    do {
		opendir DIR,$dir;
		@length=readdir(DIR);
		$count=scalar(@length);
		closedir DIR;
		
		if ($count>0) {
		    $filetoplay=int(rand $count);
		    $file=$length[$filetoplay];

		    if ((-d "$dir$file")&&$descend==1) {
			unless ($file =~ /^\./) {
			    $dir="$dir$file/";
			}
		    }
		    elsif (-f "$dir$file") {
			$size=-s "$dir$file";
			if (($size>$minmeg*$meg)&&($size<$maxmeg*$meg)) {
			    $ext=&get_ext($file);
			    # TODO - add more extensions (and allow editing thru prefs...)
			    if (($ext eq ".mp3")||($ext eq ".ogg")||($ext=".mod")) {
				$tracks++;
				$giveup=200;
				if ($first==1) {
				    system("$xmms_command -p \"$dir$file\"");
				    $first=0;
				}
				else {
				    system("$xmms_command -p -e \"$dir$file\"");
				}
			    }
			}
			$dir=$origdir;
		    }
		}
		else {
		    $giveup=0;
		}
	    } while ($tracks<$trackstoplay&&($giveup--)>0);
	    if ($giveup<=0) {
		&sig_error("$GUI_NAME could not find enough tracks fitting your request.","Try again with different values.");
	    }
	}
	&sig_complete;
	exit 0;
    }


    if ($command eq "insert") {
	# with_audio == 2 means undo delete audio
	unlink "$curtmpdir/pause";
	$img_ext=".".$ARGV[2];
	$where=$ARGV[3];
	$start=$ARGV[4];
	$end=$ARGV[5];
	$from_handle=$ARGV[6];
	$with_audio=$ARGV[7];
	$num_frames=$ARGV[8];
	$width=$ARGV[9];
	$height=$ARGV[10];
	$times=1;
	$undo_cut=0;

	chdir $curtmpdir;

	if (defined ($ARGV[17])) {
	    $times=$ARGV[17];
	    if ($times<0) {
		# this indicates undoing a previous cut
		$times=-$times;
		$undo_cut=1;
		$num_frames+=$end-$start+1;
	    }
	    else {
		if ($start>=0) {
		    &clean_old;
		}
		else {
		    # $start < 0 tells us to leave backups alone
		    $start=-$start;
		}
		$antialias=&rc_get("antialias");
	    }
	}

	if ($with_audio<2) {
	    $img_ext2=&get_img_ext("$tmpdir/$from_handle",$start);
	    &insert;
	}
	else {
	    $audio_from="$curtmpdir/audio.bak";
	}

	if ($with_audio) {
	    $fps=$ARGV[11];
	    $arate=$ARGV[12];
	    $achans=$ARGV[13];
	    $asamps=$ARGV[14];
	    $asigned=$ARGV[15];
	    $aendian=$ARGV[16];

	    if ($undo_cut==0) {
		$end/=$fps;
		$start=($start-1.)/$fps;
		$where/=$fps;
		if (-f "audio") {
		    system("cp audio audio.bak");
		    `sync;sync;sync`;
		}
	    }
	    elsif ($with_audio<2) {
                $end=-s "audio.bak";
                $end/=$arate*$achans*$asamps/8;
                $start=0.;
                $where/=$fps;
	    }
	    &insert_audio($asamps,$achans,$asigned,$aendian);
	}

	if ($undo_cut==1) {
	    &clean_old;
	}

	&sig_complete;
	exit 0;
    }

	if ($command eq "undo_insert") {
	    #clean up after an interrupted insert
	    $start=$ARGV[2];
	    $end=$ARGV[3];
	    $frames=$ARGV[4];
	    $img_ext=".".$ARGV[5];

	    # move extra frames back to end
	    `sync;sync;sync`;
	    &undo_insert;

	    $end=$frames;
	    &undo(1);
	    &undo_audio;
	    &sig_complete;
	    exit 0;
	}


    # effects

	if (substr($command,0,10) eq "pfxrender_") {
	    #fx preview
	    $fx_prev=1;
	    $command=substr($command,1);
	    $out_ext=".pre";
	}

	if (substr($command,0,9) eq "fxrender_") {

	    chdir $curtmpdir;
	    unlink "$curtmpdir/pause";
	    $command=substr($command,9);
	    $status=$ARGV[2];
	    $start=$ARGV[3];
	    $end=$ARGV[4];
	    $nwidth=$width=$ARGV[5];
	    $nheight=$height=$ARGV[6];

	    $img_ext=".".$ARGV[7];
	    splice(@ARGV,7,1);
	    
	    # call render plugins in plugins/effects/rendered/$command

	    unless (defined($fx_prev)) {
		$out_ext=".mgk";
		&clean_old;
	    }
	    if ($status==0) {
		$plugin_name="$command";
	    }
	    elsif ($status==1) {
		$plugin_name="$home/.lives-dir/plugins/effects/rendered/custom/$command";
	    }
	    else {
		$plugin_name="$home/.lives-dir/plugins/effects/rendered/test/$command";
	    }
	    $fx_desc=`$plugin_name get_description`;
	    $num_in_channels=(split(/\|/,$fx_desc))[3];
	    
	    if ($num_in_channels==0) {
		# generators get the out_extension
		$out_ext=$img_ext;
	    }

	    if ($num_in_channels==2) {
		# transitions get some extra params
		$img_ext2=".".$ARGV[7];
		splice(@ARGV,7,1);
		$start2=$ARGV[7];
		$clipboard=$ARGV[8];
	    }

	    if ($img_ext eq ".png") {
		$convert_command.=" -alpha On";
	    }

	    $fps=0;

	    $fx_caps=`$plugin_name get_capabilities`;
	    if ($fx_caps&0x8000) {
		# is autogenerated
		# we are so nice :-), we set: 
		# $handle,$curtmpdir,$img_ext,$start,$end,$width,$height
		# and for transitions $where, $chandle
		# remove fxrender $handle $status start end width height (start2 clipboard)
		shift; shift; shift; shift; shift; shift;
		if ($num_in_channels==2) {
		    shift; shift;
		}

		$ARGV[0]="process";
		if ($status>1) {
		    $error="";
		    unless (eval "require (\"$plugin_name\")") {
			$error=$@;
		    }
		    unless ($error eq "") {
			&sig_error("$plugin_name failed:","$error");
		    }
		}
		else {
		    require("$plugin_name");
		}

		if ($num_in_channels>0) {
		    unless (defined($fx_prev)) {
			&mv_mgk;
		    }
		}
		else {
		    $frames=&count_frames;
		}
		&sig_complete($nwidth,$nheight,$fps,$frames);
		exit 0;
	    }
	    else {
		# other (non-perl) language
		shift; shift; shift; #remove "fxrender_.." and $handle $status
		my ($res_file)="$curtmpdir/.rfx_result";

		my $err;

		if ($num_in_channels==2) {
		    $err=system "$plugin_name process \"$curtmpdir\" $img_ext $img_ext2 $out_ext @ARGV > $res_file";
		}
		elsif ($num_in_channels==1) {
		    $err=system "$plugin_name process \"$curtmpdir\" $img_ext $out_ext @ARGV > $res_file";
		}
		else {
		    $err=system "$plugin_name process \"$curtmpdir\" $out_ext @ARGV > $res_file";
		}
		if (!$err) {
		    if (defined(open IN,"< $res_file")) {
			read IN,$size,128;
			($nwidth,$nheight)=split(" ",$size);
			close IN;
			unlink "$res_file";
		    }
		}
		else {
		    my (@err)="";
		    if (defined(open IN,"< $res_file")) {
			read IN,$errt,512;
			@err=split("\n",$errt);
			close IN;
			unlink "$res_file";
		    }
		    &sig_error(@err);
		    exit 1;
		}
		unless (defined($fx_prev)) {
		    &mv_mgk;
		}
		&sig_complete($nwidth,$nheight);
		exit 0;
	    }
	}

	if ($command eq "import_project") {
	    $proj_file=$ARGV[2];
	    chdir $tmpdir;
	    umask 0;
	    `tar --no-same-owner -xzf \"$proj_file\"`;
	    &sig_complete;
	    exit 0;
	}

	if ($command eq "export_project") {
	    my $set=$ARGV[2];
	    my $proj_file=$ARGV[3];
	    chdir $tmpdir;
	    `tar --exclude=*.bak --exclude=.pid* --exclude .status* --exclude=lock.* --exclude=*.mgk --exclude=*.tmp --exclude=audioclip* -czf \"$proj_file\" $set`;
	    &sig_complete;
	    exit 0;
	}

	if ($command eq "bg_weed") {
	    my $bytes_cleaned=&weed;
	    &sig_complete($bytes_cleaned);
	    exit 0;
	}

	if (!caller) {
	    print STDERR "smogrify: unrecognised command $command\n";
	    exit 1;
	}
    }
    return 1;
    exit 99; # just in case
}






######################################################
    
#subroutines

sub usage {
    print STDERR "$command must have a parameter\n";
    print STDERR "show usage...\n";
}

sub mkname {
    my ($num)=shift;
    $ret=sprintf("%08d",$num);
    $ret;
}

sub check_for_pause {
    if (-f "$curtmpdir/pause") {
	`sync;sync;sync`;
    }
    while (-f "$curtmpdir/pause") {
	sleep 1;
    }
}


sub check_for_stop {
    if (defined(open IN,"< $curtmpdir/.status.fileop")) {
	close IN;
	return 1;
    }
    return 0;
}



sub get_pgid {
    #get process group for a given pid
    my $pgidstr=`cat /proc/$target_pid/stat`;
    my $pgid=(split(" ",$pgidstr))[4];
    return $pgid;
}

sub kill_child_pids {
    my $target_pid=shift;
    my $pid;
    `pgrep -P $target_pid > $tmpdir/.pids.$target_pid`;
    `kill -TERM $target_pid >/dev/null 2>&1`;
    if (-s "$tmpdir/.pids.$target_pid"&&defined(open IN,"$tmpdir/.pids.$target_pid")) {
	while (<IN>) {
	    $pid=$_;
	    chomp($pid);
	    &kill_child_pids($pid);
	}
	close IN;
    }
    unlink "$tmpdir/.pids.$target_pid";
}

sub is_writeable {
    # see if is writable or creatable
    # but do not actually create the file
    my $file=shift;
    if (! -s $nfile) {
	unlink $nfile;
    }
    $exists=(-f "$nfile");
    if (!$exists) {
	umask 0;
	system("touch \"$nfile\"; chmod o+w \"$nfile\"");
	umask $umask;
    }
    `sync;sync;sync`;
    $ret=(-w "$nfile");
    if (!$exists) {
	unlink "$nfile";
    `sync`;
    }
    return $ret;
}


sub get_img_ext {
    my $ckdir=shift;
    my $imgno=shift;

    if ($imgno eq "") {
	$imgno=1;
    }

    my $tfile=&mkname($imgno);

    if (-f "$ckdir/$tfile.png") {
	return ".png";
    }

    unless(-f "$ckdir/$tfile.jpg") {
	print STDERR "Warning ! command $command needs to set image type !! Please report this as a bug.\n";
	print STDERR "details: $ckdir/$tfile.jpg not found\n";
    }

    return ".jpg";
}
    



sub mv_mgk {
    # pass in first param as 1 to show progress of frames
    # new files are .mgk files, back up old files to .bak

    my ($option)=shift;
    my ($i,$name);

    unless (!defined($statusfile)||$statusfile eq "") {
	# don't want to get killed in this stage...
	unlink $statusfile;
    }

    for ($i=$start;$i<=$end;$i++) {
	$name=&mkname($i);
	if (-f "$curtmpdir/$name.mgk") {
		if (-f "$curtmpdir/$name$img_ext") {
		    if ($leave_bak==1&&-f "$curtmpdir/$name.bak") {
			unlink "$curtmpdir/$name$img_ext";
		    }
		    else {
			rename "$curtmpdir/$name$img_ext","$curtmpdir/$name.bak";
		    }
		}
		rename "$curtmpdir/$name.mgk","$curtmpdir/$name$img_ext";
	    }
	if ($option==1) {
	    &sig_progress($i);
	}
    }
    `sync;sync;sync`;
}




sub mv_pre {
    # new files are .pre files, back up old files to .bak
    my ($i,$name);
    unless (!defined($statusfile)||$statusfile eq "") {
	# don't want to get killed in this stage...
	unlink $statusfile;
    }

    chdir $curtmpdir;
    unlink <*.mgk>;

    for ($i=$start;$i<=$end;$i++) {
	$name=&mkname($i);
	if (-f "$curtmpdir/$name.pre") {
	    if (-f "$curtmpdir/$name$img_ext") {
		unlink "$curtmpdir/$name.bak";
		rename "$curtmpdir/$name$img_ext","$curtmpdir/$name.bak";
	    }
	    rename "$curtmpdir/$name.pre","$curtmpdir/$name$img_ext";
	}
    }
    `sync;sync;sync`;
}


sub undo {
    # recover .bak files; if param==0 or undefined, move current files to .mgk files
    my ($param)=shift;
    if ($param eq "") {
	$param=0;
    }

    my ($i,$name);
    for ($i=$start;$i<=$end;$i++) {
	$name=&mkname($i);
	if (-f "$curtmpdir/$name.bak") {
	    if ($param==0) {
		rename "$curtmpdir/$name$img_ext","$curtmpdir/$name.mgk";
	    }
	    rename "$curtmpdir/$name.bak","$curtmpdir/$name$img_ext";
	}
	&sig_progress($i);
    }
}


sub undo_audio {
    if (-f "$curtmpdir/audio.orig") {
	unlink "$curtmpdir/audio";
	rename "$curtmpdir/audio.orig","$curtmpdir/audio";
	unlink "$curtmpdir/audio.bak";
    }
    else {
	unlink "$curtmpdir/audio.new";
	rename "$curtmpdir/audio","$curtmpdir/audio.new";
	rename "$curtmpdir/audio.bak","$curtmpdir/audio";
	rename "$curtmpdir/audio.new","$curtmpdir/audio.bak";
    }
}



sub backup_audio {
    &clean_old;
    `/bin/cp $curtmpdir/audio $curtmpdir/audio.bak >/dev/null 2>&1`;
}


sub cut {
    my ($start,$end)=@_;
    my ($i,$name);
    chdir $curtmpdir;
    $frames_cut=$end-$start+1;

    for ($i=$start;$i<=$end;$i++) {
	$name=&mkname($i);
	rename "$name$img_ext","$name.bak";
	&sig_progress($i);
    }

    for ($i=$end+1;$i<=$frames;$i++) {
	$from=&mkname($i);
	$to=&mkname($i-$frames_cut);
	rename $curtmpdir."/".$from.$img_ext,$curtmpdir."/".$to.$img_ext;
	&sig_progress($i);
    }
}




sub reverse {
    for ($i=$start;$i<int(($start+$end)/2+.5);$i++) {
	$from=&mkname($i);
	$to=&mkname($end-$i+1);
	rename $curtmpdir."/".$from.$img_ext,$curtmpdir."/.revtemp";
	rename $curtmpdir."/".$to.$img_ext,$curtmpdir."/".$from.$img_ext;
	&sig_progress($start+($i-$start)*2);
	rename $curtmpdir."/.revtemp",$curtmpdir."/".$to.$img_ext;
	&sig_progress($start+($i-$start)*2+1);
    }
}



sub undo_insert {
    $frames_inserted=$end-$start+1;

    for ($i=$frames+$frames_inserted;$i>$frames;$i--) {
	# move any shifted frames back
	$name=&mkname($i);
	$to=&mkname($i-$frames_inserted);
	if (-f "$curtmpdir/$name$img_ext") {
	    unlink "$curtmpdir/$to$img_ext";
	    rename "$curtmpdir/$name$img_ext","$curtmpdir/$to$img_ext";
	}
    }
}




sub insert {
    my ($from,$to,$frames_to_move);
    $times_inserted=0;
    $factor=1;

    my ($nend)=$end;
    my ($nstart)=$start;
    my ($nwhere)=$where;
    my ($nfromdir)=$fromdir;

    my $conv_command=$convert_command;

    if ($img_ext2 eq ".jpg" && $img_ext eq ".png") {
	$conv_command.=" -alpha On";
    }

    my $quick_copy=-1;

    if (!defined($times)) {
	$times=1;
    }
    if (!defined($undo_cut)) {
	$undo_cut=0;
    }

    $fromdir="$tmpdir/$from_handle";
    $frames_to_move=($nend-$nstart+1)*$times;

    # make space for new frames
    for ($i=$num_frames;$i>$nwhere;$i--) {
	$from=&mkname($i);
	$to=&mkname($i+$frames_to_move);
	if ($i<=($num_frames-$frames_to_move)&&!$undo_cut&&-f "$curtmpdir/$from$img_ext") {
	    # this frame will get overwritten, so back it up
	    system("/bin/cp $curtmpdir/$from$img_ext $curtmpdir/$from.bak");
	}
	rename "$curtmpdir/$from$img_ext","$curtmpdir/$to$img_ext";
	&sig_progress($num_frames-$i);
    }

    $resize_ext=$img_ext;

    if (!defined($antialias)) {
	$antialias="false";
    }

    #move from $from_handle
    $j=$start;
    while ($times_inserted<$times) {
	for ($i=$nstart;$i<=$nend;$i++) {
	    $from=&mkname($i);
	    $to=&mkname($nwhere+$i-$nstart+1);

	    if ($undo_cut==1) {
		system("/bin/cp $fromdir/$from.bak $curtmpdir/$to$img_ext 2>/dev/null");
	    }
	    else {
		while (! -f "$fromdir/$from$img_ext2") {
		    print STDERR "waiting on image $fromdir/$from$img_ext2\n";
		    sleep 1;
		    `sync`;
		}

		if ($quick_copy==-1) {
		    $quick_copy=0;
		    if ($img_ext eq $img_ext2) {
			if ($height*$width==0) {
			    $quick_copy=1;
			}
			else {
			    $imresact="none";
			    &get_image_size("$fromdir/$from$img_ext2");
			    if ($hsize==$width&&$vsize==$height) {
				$quick_copy=1;
			    }
			}
		    }
		}

		if ($quick_copy==1) {
		    system("/bin/cp $fromdir/$from$img_ext2 $curtmpdir/$to$img_ext >/dev/null 2>&1");
		}
		else {
		    if ($antialias eq "false") {
			system("$conv_command +antialias -size $width"."x$height $fromdir/$from$img_ext2 -scale $width!x$height! $curtmpdir/$to$img_ext >/dev/null 2>&1");
		    }
		    else {
			system("$conv_command -antialias -size $width"."x$height $fromdir/$from$img_ext2 -scale $width!x$height! $curtmpdir/$to$img_ext >/dev/null 2>&1");
		    }
		}
		
	    }
	    
	    &sig_progress(int($num_frames-$where+$j++-$start+1));
	}

	$times_inserted+=$factor;
	$inserted=$nend-$nstart+1;

	if ($times_inserted==2) {
	    $nend=$nwhere;
	    $nstart=$nwhere-$inserted+1;
	    $fromdir=$curtmpdir;
	}
	$nwhere+=$inserted;

	if ($times_inserted>1) {
	    $nend+=$inserted;
	    $factor*=2;
	}
	while ($times>$times_inserted&&$factor>$times-$times_inserted) {
	    $nstart+=($nend-$nstart+1)/2;
	    $factor/=2;
	}
    }
}



sub resize_frame {
    my ($name,$width,$height)=@_;

    if (!defined($input_ext)) {
	$input_ext=$img_ext;
    }
    if (!defined($antialias)) {
	$antialias="false";
    }

    if ($antialias eq "false") {
	system("$convert_command +antialias -size $width"."x$height $name$input_ext -scale $width!x$height! $name$resize_ext >/dev/null 2>&1");
    }
    else {
	system("$convert_command -size $width"."x$height $name$input_ext -resize $width!x$height! $name$resize_ext >/dev/null 2>&1");
    }
}


sub zoom_frame {
    my ($name,$centre_x,$centre_y,$width,$height,$rscale)=@_;
    # zoom into a frame

    # first we will crop the frame to just slightly larger than
    # our target, then we will resize, then do an exact crop
    
    # TODO - if we expand an edge a lot, our final crop needs
    # adjusting

    if (!defined($antialias)) {
	$antialias="false";
    }
    if (!defined($input_ext)) {
	$input_ext=$img_ext;
    }
    
    my ($left)=int($centre_x-($width/(2.*$rscale)))-1;
    my ($top)=int($centre_y-($height/(2.*$rscale)))-1;
    my ($right)=int($centre_x+($width/(2.*$rscale)))+1;
    my ($bottom)=int($centre_y+($height/(2.*$rscale)))+1;
    
    if ($left<0) {
	$right-=$left;
	$left=0;
    }
    if ($top<0) {
	$bottom-=$top;
	$top=0;
    }
    if ($right>=$width) {
	$left-=$right-$width+1;
	if($left<0) {
	    $left=0;
	}
	$right=$width-1;
    }
    if ($bottom>=$height) {
	$top-=$bottom-$height+1;
	if($top<0) {
	    $top=0;
	}
	$bottom=$height-1;
    }
    my ($nwidth)=$right-$left+1;
    my ($nheight)=$bottom-$top+1;
    
    if ($antialias eq "false") {
	system("$convert_command -antialias -size $width"."x$height $name$input_ext -crop $nwidth!x$nheight!+$left!+$top! -resize $width!x$height! $name$resize_ext >/dev/null 2>&1");
    }
    else {
	system("$convert_command +antialias -size $width"."x$height $name$input_ext -crop $nwidth!x$nheight!+$left!+$top! -resize $width!x$height! $name$resize_ext >/dev/null 2>&1");
    }
    
}





sub trim_frame {
    my ($name,$width,$height,$x,$y,$nwidth,$nheight)=@_;

    if (!defined($input_ext)) {
	$input_ext=$img_ext;
    }
    if (!defined($antialias)) {
	$antialias="false";
    }
    if ($antialias eq "false") {
	system("$convert_command +antialias -size $width"."x$height $name$input_ext -crop $nwidth!x$nheight!+$x+$y $name$resize_ext >/dev/null 2>&1");
    }
    else {
	system("$convert_command -antialias -size $width"."x$height $name$input_ext -crop $nwidth!x$nheight!+$x+$y $name$resize_ext >/dev/null 2>&1");
    }
}

sub trim_center {
    my ($name,$width,$height)=@_;

    if (!defined($input_ext)) {
	$input_ext=$img_ext;
    }

    $imresact="none";
    &get_image_size("$name$input_ext");

    unless ($hsize>=$width&&$vsize>=$height) {
	#composite over a large enough frame
	$size=$hsize;
	if ($vsize>$size) {
	    $size=$vsize;
	}

	$xstart=int(($size-$hsize)/2);
	$ystart=int(($size-$vsize)/2);

	# make a background frame
	if (!defined($bgcolour)) {
	    $bgcolour="#000000";
	}

	system("$convert_command -size $size!x$size! xc:$bgcolour blank.jpg >/dev/null 2>&1");
	system("$composite_command -compose plus -dissolve 100 -geometry $hsize!x$vsize!+$xstart!+$ystart! $name$input_ext blank.jpg $name$input_ext >/dev/null 2>&1");
	$hsize=$vsize=$size;
    }

    $x=int(($hsize-$width)/2);
    $y=int(($vsize-$height)/2);

    system("$convert_command $name$input_ext -crop $width" . "!x" . $height . "!+" . $x . "+" . $y . " $name$resize_ext >/dev/null 2>&1");

}


sub get_ext {
    # return the extension of a file (including the '.')
    my ($file)=shift;
    return substr($file,-4);
}



sub get_formats {
    if ($asamps==8){
	$format=16;
	$signed=0;
	$xsigned="-u";
    }
    else {
	$signed=1;
	$xsigned="-s";
	if ($endian==1) {
	    # little
	    $format=128;
	}
	else {
	    # big
	    $format=256;
	}
    }
}




sub get_file_info {
    $af_size=0;
    $count=0;
    $bpp=24;  # default if none is found
    $fps=0; # let the front-end handle this if we can't get it ;-)
    $type="Unknown";
    $hsize=0;
    $vsize=0;
    $signed=-1;
    $f_size=0;
    $arate=$asamps=$achans=0;
    $frames=0;
    $asamps=0;

    # try to force language to English
    $mplay_command="LANGUAGE=en LANG=en ";

    $mplay_command.=&rc_get("video_open_command");
    $file_ident="$curtmpdir/file_info";

    $id_vid_form="";

    if ($is_audio) {
	$type="Audio";
    }

    # if mplayer supports the -identify command, use that
    # the format changed for 1.0pre1 so now we use -vo null -ao null -frames 0

    unless ($mplay_command eq "") {
    if (defined($is_remote)&&($is_remote>0)) {
	# remote files might be streams, so we need to cache a bit before we can identify them
	system("$mplay_command -identify -vo null -ao null -frames 0 -cache 32 \"$file\">$file_ident 2>/dev/null </dev/null");
    }
    else {
	system("$mplay_command -identify -vo null -ao null -frames 0 \"$file\">$file_ident 2>/dev/null </dev/null");
    }

    if (-f $file_ident) {
        $id_vid_form=`grep ID_VIDEO_CODEC $file_ident 2>/dev/null`;
        $id_vid_form=(split("=",(split("\n",$id_vid_form))[0]))[1];
        chomp($id_vid_form);

	if ($id_vid_form eq "") {
	    $id_vid_form=`grep ID_VIDEO_FORMAT $file_ident 2>/dev/null`;
	    $id_vid_form=(split("=",(split("\n",$id_vid_form))[0]))[1];
	    chomp($id_vid_form);
	}

	if ($id_vid_form eq "") {
	    $id_vid_form=`grep VIDEO: $file_ident 2>/dev/null`;
	    $id_vid_form=(split("  ",(split("\n",$id_vid_form))[0]))[1];
	    chomp($id_vid_form);
	}
	if (! -f $file_ident) {return;};

	$id_aud_form=`grep ID_AUDIO_FORMAT $file_ident 2>/dev/null`;
	$id_aud_form=(split("=",(split("\n",$id_aud_form))[0]))[1];
	chomp($id_aud_form);

	if ($id_aud_form eq "") {
	    $id_aud_form=`grep AUDIO: $file_ident 2>/dev/null`;
	    $id_aud_form=(split("  ",(split("\n",$id_aud_form))[0]))[1];
	    chomp($id_aud_form);
	}

	if (! -f $file_ident) {return;};

	if ($id_vid_form eq "") {
	    if (!($id_aud_form eq "")) {
		$id_vid_form="Audio";
	    }
	}

	unless ($id_vid_form eq "") {
	    # this could probably be done better using regexp...
	    $type=$id_vid_form;
	    if (! -f $file_ident) {return;};
	    $asamps=`grep AUDIO: $file_ident 2>/dev/null`;
	    $asamps=(split(" ",$asamps))[5];
	    chomp($asamps);

	    if ($asamps =~ /^s/) {
		$asamps=substr($asamps,1,-1);
		$signed=1;
	    }
	    if ($asamps =~ /^u/) {
		$asamps=substr($asamps,1,-1);
		$signed=0;
	    }

	    if (! -f $file_ident) {return;};
	    $bpp=`grep VIDEO: $file_ident 2>/dev/null`;
	    $bpp=(split("bpp",(split("  ",$bpp))[3]))[0];
	    chomp($bpp);

	    if (! -f $file_ident) {return;};
	    if ($bpp eq "") {
		$bpp=`grep \"Image size:\" $file_ident 2>/dev/null`;
		@tmp=split(" ",$bpp);
		$bpp=substr($tmp[5],1,2);
	    }

	    if (! -f $file_ident) {return;};
	    $hsize=`grep ID_VIDEO_WIDTH $file_ident 2>/dev/null`;
	    $hsize=(split("=",(split("\n",$hsize))[0]))[1];
	    chomp($hsize);
	    
	    if (! -f $file_ident) {return;};
	    $vsize=`grep ID_VIDEO_HEIGHT $file_ident 2>/dev/null`;
	    $vsize=(split("=",(split("\n",$vsize))[0]))[1];
	    chomp($vsize);
	    
	    if (! -f $file_ident) {return;};
	    $fps=`grep ID_VIDEO_FPS $file_ident 2>/dev/null`;
	    $fps=(split("=",(split("\n",$fps))[0]))[1];
	    chomp($fps);

	    if (! -f $file_ident) {return;};
	    $arate=`grep ID_AUDIO_RATE $file_ident 2>/dev/null`;
	    my @results=split("\n",$arate);
	    foreach my $val (@results) {
		$arate=(split("=",$val))[1];
		chomp($arate);
		last if $arate>0;
	    }
	    if (! -f $file_ident) {return;};
	    if ($arate==0) {
		$arate=`grep Samplerate $file_ident 2>/dev/null`;
		$arate=(split(": ",(split("\n",$arate))[0]))[1];
		chomp($arate);
	    }

	    
	    if (! -f $file_ident) {return;};
	    $achans=`grep ID_AUDIO_NCH $file_ident 2>/dev/null`;
	    chomp($achans);
	    $achans=(split("\n",$achans))[-1];
	    $achans=(split("=",(split("\n",$achans))[0]))[1];

	    if (! -f $file_ident) {return;};
	    $abitrate=`grep ID_AUDIO_BITRATE $file_ident 2>/dev/null`;
	    chomp($abitrate);
	    $abitrate=(split("\n",$abitrate))[-1];
	    $abitrate=(split("=",(split("\n",$abitrate))[0]))[1];


	    unless ($id_aud_form eq "" || $achans>0) {
		# need to look deeper for $achans
		$adets=`grep AO: $file_ident 2>/dev/null`;

		$adets=(split("AO: ",$adets))[1];
		chomp($adets);

		$arate=(split(" ",$adets))[1];
		if ($arate eq "[oss]") {
		    $arate=(split(" ",$adets))[2];
		    $achans=(split(" ",$adets))[3];

		}
		else {
		    $achans=(split(" ",$adets))[2];
		}
		chomp($arate);
		chomp($achans);

		$arate=$arate*1;
		$achans=$achans*1;
	    }

	    if (! -f $file_ident) {return;};
	    $comment=`grep Comments: $file_ident 2>/dev/null`;
	    @tmp=split(" ",$comment);
	    shift(@tmp);
	    $comment=join(" ",@tmp);
	    chomp($comment);

	    if (! -f $file_ident) {return;};
	    $title=`grep Title: $file_ident 2>/dev/null`;
	    @tmp=split(" ",$title);
	    shift(@tmp);
	    $title=join(" ",@tmp);
	    chomp($title);

	    if (! -f $file_ident) {return;};
	    $title=`grep Author: $file_ident 2>/dev/null`;
	    @tmp=split(" ",$author);
	    shift(@tmp);
	    $author=join(" ",@tmp);
	    chomp($author);

	    if (! -f $file_ident) {return;};
	    $count=`grep \"frames  total\" $file_ident 2>/dev/null`;
	    @tmp=split(" ",$count);
	    $count=$tmp[2];
	    chomp($count);

            if ($count eq "") {
                $length=`grep ID_LENGTH $file_ident 2>/dev/null`;
                $length=(split("=",(split("\n",$length))[0]))[1];
                chomp($length);
                $count=int($fps*$length+.5);
            }
            if ($count eq "") {
                $count=1000000; #take a guess...
            }
	}
	if ($asamps==0&&$arate*$achans>0) {
	    $asamps=$abitrate/$arate/$achans;
	}
	unlink $file_ident;
    }
   }


    if (($hsize*$vsize==0||$count eq "")&&!$is_audio) {
	# test even if mplayer thinks it is audio (at least some png files are misread)
	$name=&mkname(1);
	unless (-f "$curtmpdir/$name") {
	    # see if it is image(s)
	    &open_images(1);
	    opendir DIR,$curtmpdir;
	    while ($file2=readdir(DIR)) {
		if ($file2 =~ /$img_ext$/) {
		    $count++;
		    $imresact="none";
		    if ($only_first) {
			unlink <$curtmpdir/*$img_ext>;
			last;
		    }
		    else {
			$f_size+=-s $file2;
		    }
		}
		else {
		    unless ($file2 eq $audio_in) {
			unlink $file2;
		    }
		}
	    }
	    closedir DIR;

	    if ($count) {
		# got image(s)
		$frames=$count;
		# got image(s)
		if ($img_ext eq ".jpg") {
		    $type="jpeg";
		}
		else {
		    $type="png";
		}
		
		$count=0;
		$name=&mkname(1);
	    }
	}
    }

    if ($signed==-1) {
	if ($asamps==8) {
	    $signed=0;
	}
	else {
	    $signed=1;
	}
    }

    $endian=&get_endian; # assume audio endian matches machine endian

    # get file size
    if ($f_size==0) {
	$f_size= -s $file;
    }

    if ($asamps<5&&$asamps>0) {
	$asamps=16;
    }
    
    if ($type=~ m/^\[/) {
	$type=substr($type,1,-1);
    }

}





sub convert_audio_to_raw {
    &get_formats;
    if (!(&rc_get("audio_player") eq "mplayer")) {
	system("sox -t .wav $audio_in -t .raw $xsigned $audio_out > /dev/null 2>&1");
    }
    else {
	$format=&get_mplayer_format;
	system(&rc_get("video_open_command") . " -quiet $audio_in -ao pcm:nowaveheader:file=$audio_out $format >/dev/null 2>&1");
    }

    `sync;sync;sync`;
}


sub convert_audio_to_wav {
    #WARNING - $asamps and $nasamps are in bits
    my ($aasamps)=$asamps/8;

    chdir $curtmpdir;
    if (&rc_get("audio_player") eq "mplayer") {
	$format=&get_mplayer_format;
	system(&rc_get("video_open_command") . " -quiet -ao pcm -demuxer rawaudio -rawaudio rate=$arate:channels=$achans:samplesize=$aasamps -ao pcm:waveheader $format -vo null $audio_in >/dev/null 2>&1 </dev/null");
    }
    else {

	if (!defined($sox_version)) {
	    $sox_version=&get_sox_version;
	}

	if ($sox_version<13) {
	    $nodither="";
	    if ($asamps==8) {
		$sasamps="b";
	    }
	    else {
		$sasamps="w";
	    }
	}
	else {
	    $nodither="-D";
	    $sasamps=$aasamps;
	}


	if (!defined($nrate)) {
	    $nrate=$arate;
	}

	if (!defined($nchans)) {
	    $nchans=$achans;
	}

	if (!defined($nasamps)) {
	    $nasamps=$sasamps;
	}

	if (!defined($asigned)) {
	    if ($sasamps==8) {
		$asigned="-u";
	    }
	    else {
		$asigned="-s";
	    }
	}

	if (!defined($nsigned)) {
	    if ($nasamps==8) {
		$nsigned="-u";
	    }
	    else {
		$nsigned=$asigned;
	    }
	}
	system("sox $nodither -t .raw -r $arate $asigned -$sasamps -c $achans $audio_in -t .wav -r $nrate -c $nchans $nsigned -$nasamps $curtmpdir/audiodump.wav >/dev/null 2>&1");
    }

    `sync;sync;sync`;
}





#clip (actually, trim) the audio from $start seconds to $end seconds
sub clip_audio {
    my ($start,$end)=@_;

    if ($achans==0) {
	return;
    }

    $audio_in=$curtmpdir."/audio";
    $audio_out=$curtmpdir."/audioclip";

    unlink $audio_out;
    `touch $audio_out; chmod 600 $audio_out`;

    $align=$achans*$asamps/8;

    $spos=&align($arate*$align*$start);
    $epos=&align($arate*$align*$end);

    my ($fsize)= (-s $audio_in);

    if ($epos>$fsize) {
	$epos=$fsize;
    }
    if ($spos>$epos) {
	$spos=$epos;
    }

    my ($size)=($epos-$spos);

    if ($size>0) {
	$fblocks=int($size/32);
	$rblocks=$size-($fblocks*32);
	unlink $audio_out;
	system("dd if=$audio_in of=$audio_out bs=32 count=$fblocks skip=".int($spos/32)." >/dev/null 2>&1");
	system("dd if=$audio_in of=$audio_out bs=1 count=$rblocks skip=".($spos+$fblocks*32)." seek=".($fblocks*32)." >/dev/null 2>&1");
    }

    `sync;sync;sync`;
    $audio_out;
}


sub resample_audio {
    #WARNING - $asamps and $nasamps are in bits

    $endian=&get_endian;

    if (!defined($sox_version)) {
	$sox_version=&get_sox_version;
    }
    
    if ($sox_version<13) {
	if ($asamps==8) {
	    $osamps="b";
	}
	else {
	    $osamps="w";
	}
	
	
	if ($nsamps==8) {
	    $nsamps="b";
	}
	else {
	    $nsamps="w";
	}
	$nodither="";
    }
    else {
	$osamps=$asamps/8;
	$nsamps/=8;
	$nodither="-D";
    }
    
    if ($asigned==1) {
	$osigned="s";
    }
    else {
	$osigned="u";
    }
    
    if ($nsigned==1) {
	$nsigned="s";
    }
    else {
	$nsigned="u";
    }
    
    if ($aendian==$endian) {
	$oendian="";
    }
    else {
	$oendian="-x";
    }
    
    if ($nendian==$endian) {
	$nendian="";
    }
    else {
	$nendian="-x";
    }
    
    if (defined($stretch)) {
	system("sox $nodither -t .raw -r $arate -c $achans -$osigned -$osamps $oendian $audio_in -t .raw -r $nrate -c $nchans -$nsigned $nendian -$nsamps $audio_out stretch $stretch>/dev/null 2>&1");
    }
    else {
	system("sox $nodither -t .raw -r $arate -c $achans -$osigned -$osamps $oendian $audio_in -t .raw -r $nrate -c $nchans -$nsigned $nendian -$nsamps $audio_out>/dev/null 2>&1");
    }
}




sub insert_audio {
#what we are going to do:
# 1) copy the end of the audio (after insertion) to a new file
# 2) then insert the new section
# 3) then put the end back

#input params:
# $where - insertion pt -in seconds
# $start, $end - new section - in seconds
# $from_handle - handle of from file

    #if $arate<0, we will insert silence

    my ($xxsamps,$xxchans,$xxsigned,$xxendian)=@_;

    if ($achans==0) {
	return;
    }

    if (!defined($times)) {
	$times=1;
    }

    my ($audio_from)=$audio_from;

    my ($audio_to)="$curtmpdir/audio";
    if (defined($from_handle)) {
	if ($undo_cut>0) {
	    $audio_from="$tmpdir/$from_handle/audio.bak";
	}
	else {
	    $audio_from="$tmpdir/$from_handle/audio";
	}
    }
    my ($audio_temp)="$curtmpdir/audio.temp";

    unlink $audio_temp;
    `touch $audio_temp; chmod 600 $audio_temp`;

    $silence=0;
    if ($arate<0) {
	$silence=1;
	$arate=-$arate;
    }

    $align=$achans*$asamps/8;

    $spos=&align($arate*$align*$start);
    $oepos=$epos=&align($arate*$align*$end);
    $wpos=&align($arate*$align*$where);

    if ($silence==0) {
	$fsize=&align(-s $audio_from);
	if ($epos>$fsize) {
	    $epos=$fsize;
	}
	if ($spos>$epos) {
	    $spos=$epos;
	}
    }

    # step 1 - move end to temp
    $fsize=-s $audio_to;

    my ($size)=$fsize-$wpos;
    if ($size>0) {
	$fblocks=int($size/32);
	$rblocks=$size-($fblocks*32);
	system("dd if=$audio_to of=$audio_temp bs=32 count=$fblocks skip=".int($wpos/32)." >/dev/null 2>&1");
	system("dd if=$audio_to of=$audio_temp bs=1 count=$rblocks skip=".($wpos+$fblocks*32)." seek=".($fblocks*32)." >/dev/null 2>&1");
    }

    # step 2 - insert new section (possibly multiple times)


    # pad with silence to insertion point
    &append_silence($wpos,$xxsamps,$xxchans,$xxsigned,$xxendian);

####################################################
    my ($nepos)=$epos;
    my ($nspos)=$spos;
    my ($nwpos)=$wpos;

    $times_inserted=0;
    $factor=1;
    $silence_remembered=0;

    my ($xaudio_from)=$audio_from;

    while ($times_inserted<$times) {
	$size=$nepos-$nspos;
	if ($size>0) {
	    if ($silence) {
		&append_silence($nwpos+$size,$xxsamps,$xxchans,$xxsigned,$xxendian);
	    }
	    else {
		$fblocks=int($size/32);
		$rblocks=$size-($fblocks*32);
		system("dd if=$xaudio_from of=$audio_to bs=32 count=$fblocks skip=".int($nspos/32)." seek=".int($nwpos/32)." >/dev/null 2>&1");
		system("dd if=$xaudio_from of=$audio_to bs=1 count=$rblocks skip=".($nspos+$fblocks*32)." seek=".($nwpos+$fblocks*32)." >/dev/null 2>&1");
	    }
	}
	
	$times_inserted+=$factor;
	# pad with silence if necessary
	if (-s $audio_temp||$times_inserted<$times) {
	    $inserted=$oepos-$nspos;
	    &append_silence($nwpos+$inserted,$xxsamps,$xxchans,$xxsigned,$xxendian);
	    unless ($silence_remembered>0) {
		$silence_remembered=$oepos-$nepos;
	    }
	}
	else {
	    $inserted=$nepos-$nspos;
	}

	if ($times_inserted==2) {
	    $oepos=$nepos=$nwpos;
	    $nspos=$nwpos-$inserted;
	    $xaudio_from=$audio_to;
	}

	$nwpos+=$inserted;

	if ($times_inserted>1) {
	    $nepos+=$inserted;
	    $oepos+=$inserted;
	    $factor*=2;
	}
	while ($times>$times_inserted&&$factor>$times-$times_inserted) {
	    $nspos+=($oepos-$nspos)/2;
	    $factor/=2;
	}
	if ($factor+$times_inserted==$times) {
	    # this will be our last insertion...
	    if (-s $audio_temp==0) {
		$nepos-=$silence_remembered;
	    }
	}
    }


####################################################

    #step 3 - copy end back after insertion
    $size=&align(-s $audio_temp);
    if ($size>0) {
	$fblocks=int($size/32);
	$rblocks=$size-($fblocks*32);
	system("dd if=$audio_temp of=$audio_to bs=32 count=$fblocks seek=".int(($nwpos)/32)." >/dev/null 2>&1");
	system("dd if=$audio_temp of=$audio_to bs=1 count=$rblocks skip=".($fblocks*32)." seek=".($nwpos+$fblocks*32)." >/dev/null 2>&1");
    }

    unlink $audio_temp;
    `sync;sync;sync`;
}



sub cut_audio {
#what we are going to do:
    #1) copy up to $start to a new file
    #2) back up the section to be deleted
    #3) append the section after $end to the new file
    #4) copy the new file to the original
    #$start, $end are in seconds

    if ($achans==0) {
	return;
    }

    my ($audio_in)="$curtmpdir/audio";
    my ($audio_temp)="$curtmpdir/audio.temp";
    my ($audio_bak)="$curtmpdir/audio.bak";

    unlink $audio_temp;
    unlink $audio_bak;

    if ($end==0.) {
	rename ($audio_in,$audio_bak);
    }
    else {
	`touch $audio_temp; chmod 600 $audio_temp`;
	
	$align=$achans*$asamps/8;
	
	# step 1
	$spos=&align($arate*$align*$start);
	$epos=&align($arate*$align*$end);
	
	my ($fsize)=&align(-s $audio_in);
	
	if ($epos>$fsize) {
	    $epos=$fsize;
	}
	if ($spos>$epos) {
	    $spos=$epos;
	}
	
	$seekstart=$spos;
	my ($size)=$spos;
	
	if ($size>0) {
	    $fblocks=int($size/32);
	    $rblocks=$size-($fblocks*32);
	    system("dd if=$audio_in of=$audio_temp bs=32 count=$fblocks >/dev/null 2>&1");
	    system("dd if=$audio_in of=$audio_temp bs=1 count=$rblocks skip=".($fblocks*32)." seek=".($fblocks*32)." >/dev/null 2>&1");
	}
	
	#step 2
	$size=($epos-$spos);
	
	if ($size>0) {
	    $fblocks=int($size/32);
	    $rblocks=$size-($fblocks*32);
	    system("dd if=$audio_in of=$audio_bak bs=32 skip=".int($spos/32)." count=$fblocks >/dev/null 2>&1");
	    system("dd if=$audio_in of=$audio_bak bs=1 count=$rblocks skip=".($spos+$fblocks*32)." seek=".($fblocks*32)." >/dev/null 2>&1");
	}
	
	
	#step 3
	$spos=$epos;
	$epos=$fsize;
	$size=($epos-$spos);
	
	if ($size>0) {
	    $fblocks=int($size/32);
	    $rblocks=$size-($fblocks*32);
	    system("dd if=$audio_in of=$audio_temp bs=32 count=$fblocks skip=".int($spos/32)." seek=".int($seekstart/32)." >/dev/null 2>&1");
	    system("dd if=$audio_in of=$audio_temp bs=1 count=$rblocks skip=".($spos+$fblocks*32)." seek=".($seekstart+$fblocks*32)." >/dev/null 2>&1");
	}
	
	# step 4
	unlink $audio_in;
	rename "$audio_temp", "$audio_in";
    }
    `sync;sync;sync`;

}


sub align {
    my ($guess)=shift;
    # align our audio cuts so we don't end halfway through a sample/channel
    if (!defined($align)) {
	$align=$achans*$asamps/8;
    }
    $guess=int($guess/$align+.5)*$align;
    return $guess;
}


sub append_silence {
    #pad from end of file to byte $end-1 with zeros
    my ($end,$asamps,$achans,$asigned,$aendian,$audio_file)=@_;
    if ($audio_file eq "") {
	$audio_file="$curtmpdir/audio";
    }

    unless (-f $audio_file) {
	`touch $audio_file; chmod 600 $audio_file`;
    }

    my ($fsize)= -s $audio_file;
    $size=&align($end-$fsize);

    if ($size>0) {
	if ($asigned==1) {
	    $fblocks=int($size/32);
	    $rblocks=$size-($fblocks*32);
	    system("dd if=/dev/zero of=$audio_file bs=32 count=$fblocks seek=".int($fsize/32)." >/dev/null 2>&1");
	    system("dd if=/dev/zero of=$audio_file bs=1 count=$rblocks seek=".($fsize+$fblocks*32)." >/dev/null 2>&1");
	}
	else {
	    open AUD,">> $audio_file";
	    if ($asamps==8) {
		for ($i=0;$i<$size;$i++) {
		    print AUD chr(128);
		}
	    }
	    else {
		if ($aendian) {
		    for ($i=0;$i<$size;$i+=2*$achans) {
			for ($j=0;$j<$achans;$j++) {
			    print AUD chr(0);
			    print AUD chr(128);
			}
		    }
		}
		else {
		    for ($i=0;$i<$size;$i+=2*$achans) {
			for ($j=0;$j<$achans;$j++) {
			    print AUD chr(128);
			    print AUD chr(0);
			}
		    }
		}
	    }
	    close AUD;
	}
    }
}





sub open_images {
    # set $file before calling this function
    # set $only_first to 1 to just open the first image in a directory
    # set $height $width to force a particular size, otherwise $height=$width=0 to open all to the first image size
    # if first image size cannot be obtained $dwidth and $dheight are used

    my ($i)=shift;
    my $orig=$i;

    if (-d $file) {
	# is a directory

	$dir=$file;
	opendir DIR,$dir;
	my @files=readdir(DIR);
	closedir DIR;

	unless ($only_first) {
	    # open in numeric order
	    @files = sort {byfile($a,$b)} (@files);
	    if (!defined($antialias)) {
		$antialias=&rc_get("antialias");
	    }
	}

	foreach (@files) {
	    $file="$dir/$_";
	    unless ($_ =~ /^\./||(! -f $file)||(-z $file)) {
		$nframes=&open_single_image($i);
		if (-s "$curtmpdir/$name$img_ext") {
		    if ($only_first) {
			$i++;
			last;
		    }
		    else {
			$i+=$nframes;
		    }
		}
		else {
		    unlink "$curtmpdir/$name$img_ext";
		}
	    }
	}
    }
    else {
	&open_single_image($i);
	unless (-s "$curtmpdir/$name$img_ext") {
	    unlink "$curtmpdir/$name$img_ext";
	}
    }
    return $i-$orig;
}



sub byfile {
    #thanks to dominus !
    my @a = split /(\d+)/, $a;
    my @b = split /(\d+)/, $b;
    my $M = @a > @b ? @a : @b;
    my $res = 0;
    for (my $i = 0; $i < $M; $i++) {
	return -1 if ! defined $a[$i];
	return 1 if  ! defined $b[$i];
	if ($a[$i] =~ /\d/) {
	    $res = $a[$i] <=> $b[$i];
	} else {
	    $res = $a[$i] cmp $b[$i];
	}
	last if $res;
    }
    $res;
}





sub open_single_image {
    # set $hsize and $vsize to force the image size, set to 0 to autoresize
    #identify hangs if the file extension is ".avi" or ".mp4" or ".mpg"

    my $i=shift;
    my $j;
    $name=&mkname($i);
    my $nframes=0;

    my $conv_command=$convert_command;

    if (!defined($file_ext)) {
	$file_ext=&get_ext($file);
    }

    # TODO - return for any streams (anything with a :// in)

    if ($file_ext eq ".avi"||$file_ext eq ".mp4"||$file_ext eq ".mpg"||$file_ext eq ".ogg") {
	# need to set $name before we return
	return 0;
    }

    if ($hsize*$vsize==0) {
	&get_image_size($file);
    }

    `sync;sync;sync`;

    if ($img_ext eq ".png") {
	$conv_command.=" -alpha On";
    }

    if ($antialias eq "false") {
	system("$conv_command +antialias \"$file\" -scale $hsize"."!x"."$vsize! $curtmpdir/$name$img_ext > /dev/null 2>&1");
    }
    else {
	system("$conv_command \"$file\" -resize $hsize"."!x"."$vsize! $curtmpdir/$name$img_ext >/dev/null 2>&1");
    }

    #convert gives multiple frames for e.g. animated gif
    $found=1;
    for ($j=0;$found==1;$j++) {
	if (-f "$curtmpdir/$name-$j$img_ext") {
	    $newname=&mkname($i+$j);
	    rename "$curtmpdir/$name-$j$img_ext","$curtmpdir/$newname$img_ext";
	    $nframes++;

	}
	else {
	    $found=0;
	}
    }

    if ($hsize*$vsize==0) {
	&get_image_size("$curtmpdir/$name$img_ext");
    }

    if ($hsize*$vsize>0&&$nframes==0) {
	$nframes=1;
    }

    return $nframes;

}



sub get_image_size {
    # returns $hsize,$vsize and $bpp for $1
    my ($file)=shift;
    my ($i);

    #identify hangs if the file extension is ".avi" or ".mp4"...maybe more...
    my ($file_ext)=&get_ext($file);

    if ($file_ext eq ".avi"||$file_ext eq ".mp4"||$file_ext eq ".mpg") {
	$height=$width=$bpp=0;
	return;
    }

    $bpp=8; # default for images
    if (!defined($imresact)) {
	$imresact=&rc_get("image_resize_action");
    }

    # imresact can be: default - resize all images to default; bound - use as max size but keep aspect (e.g. for thumbnails); or none: return actual size

    my ($id_cmd)=&location("identify");

    unless ($id_cmd eq "") {
	@info=split / /, `$id_cmd \"$file\" 2>/dev/null`;


	my ($file2)=$file;
	$space_count=($file2 =~ tr/ //);
	for ($i=0;$i<$space_count;$i++) {
	    shift(@info);
	}
	$bppstr=$info[4];
	@bpp=split /-/,$bppstr;
	$bpp=$bpp[0];
	@sizestr=split /\+/,$info[2];
	@size=split /x/,$sizestr[0];

	$hsize=$size[0];
	$vsize=$size[1];
	
	if ($imresact eq ""||$imresact eq "default") {
	    $hsize=$vsize="";
	}
	elsif ($imresact eq "bound") {
	    if ($hsize>$dwidth) {
		$shrink=$hsize/$dwidth;
		$hsize/=$shrink;
		$vsize/=$shrink;
	    }
	    if ($vsize>$dheight) {
		$shrink=$vsize/$dheight;
		$hsize/=$shrink;
		$vsize/=$shrink;
	    }
	    $hsize=int($hsize);
	    $vsize=int($vsize);
	}
    }
    if (!defined($hsize)||$hsize eq "") {
	$hsize=$dwidth;
    }
    if (!defined($vsize)||$vsize eq "") {
	$vsize=$dheight;
    }
}




sub fill_and_redo_frames {
    # resample and fill gaps in frames

    my $conv_command=$convert_command;
    my $next=0;

    chdir $curtmpdir;

    if ($img_ext eq ".png") {
	$conv_command.=" -alpha On";
    }
    
    for ($i=1;$i<=$end;$i++) {
	$name=&mkname($i);

	if ($next<$i&&$next>-1) {
	    $last=$next;
	    $next=&get_next_frame;
	}
	if ($last>0&&($i-$last)<($next-$i)) {
	    $fromname=&mkname($last);
	}
	else {
	    $fromname=&mkname($next);
	}

	unless ($fromname eq $name) {
	    system("/bin/cp $fromname$img_ext $name$img_ext");
	}
	&sig_progress($i);
    }

}


sub get_next_frame {
    my $j;
    my $xname;

    for ($j=$i;$j<=$end;$j++) {
	$xname=&mkname($j);
	if (-f "$xname$img_ext") {
	    # found next frame, resize it
	    system("$conv_command -crop $width" . "!x" . $height . "! $xname$img_ext $xname.mgk >/dev/null 2>&1");
	    unlink "$xname$img_ext";
	    rename "$xname.mgk","$xname$img_ext";
	    return $j;
	}
    }
    # no next frame found
    return -1;
}




sub mp3_open {
    if (-f $audio_in) {
	unlink $audio_in;
    }
    $f_size=0;

    # prefer mpg321 if it's available
    unless (&location("mpg321") eq "") {
	system("mpg321 -w $audio_in --rate 44100 --stereo \"$file\" >/dev/null 2>&1");
	$f_size=-s $audio_in;
    }
    if ($f_size==0) {
	unless (&location("mpg123") eq "") {
	    system("mpg123 -w $audio_in --rate 44100 --stereo \"$file\" >/dev/null 2>&1");
	    $f_size=-s $audio_in;
	}
    }
    if ($f_size==0) {
	&othera_open;
	return;
    }

    $arate=44100;
    $achans=2;
    $asamps=16;

    $asigned=1;
    if ($asamps==8) {
	$asigned=0;
    }
    $aendian=&get_endian;
    $f_size=-s $audio_in;
}


sub ogg_open {
    if (-f $audio_in) {
	unlink $audio_in;
    }
    
    system("ogg123 -d wav -f $audio_in \"$file\" >/dev/null 2>&1");
    $f_size= -s $audiofile;

    if ($f_size==0) {
	&othera_open;
	return;
    }

    # values are assumed here
    $arate=44100;
    $achans=2;
    $asamps=16;

    $asigned=1;
    if ($asamps==8) {
	$asigned=0;
    }
    $aendian=&get_endian;
}


sub wav_open {
    $mplay_command=&rc_get("video_open_command");
    $curtmpfile=$curtmpdir . "/.temp";

    if (-f $audio_in) {
	unlink $audio_in;
    }
    
    system("cp \"$file\" $audio_in");
    system("$mplay_command -frames 0 $audio_in > $curtmpfile 2>/dev/null </dev/null");
    
    @info2=split / /, `grep AUDIO: $curtmpfile`;
    unlink $curtmpfile;
    $arate=$info2[1];
    $achans=$info2[3];
    $asamps=$info2[5];


    if ($arate==0&&$achans==0&&$asamps==0) {
	# TODO - find way to read these
	# have to assume these for now
	$arate=44100;
	$achans=2;
	$asamps=16;
    }
    
    # and it seems we *must* assume these...
    $asigned=1;
    if ($asamps==8) {
	$asigned=0;
    }
    $aendian=&get_endian;

    $f_size= -s $audio_in;
}



sub othera_open {
    $arate=44100;
    $achans=2;
    $asamps=16;
    $aendian=&get_endian;
    $asigned=1;
    $format=&get_mplayer_format;

    system(&rc_get("video_open_command") . " -quiet \"$file\" -ao pcm:waveheader:file=$audio_in $format >/dev/null 2>&1 </dev/null");
    $f_size=-s $audio_in;
}



################################################
# utility subroutines

sub get_current_date {
    ($Second, $Minute, $Hour, $Day, $Month, $Year, $WeekDay, $DayOfYear, $IsDST) = localtime(time);
    my $RealMonth = $Month + 1; # Months of the year are not zero-based

    if($RealMonth < 10)
    {
	$RealMonth = "0" . $RealMonth; # add a leading zero to one-digit months
    }
    if($Day < 10)
    {
	$Day = "0" . $Day; # add a leading zero to one-digit days
    }
    
    $Fixed_Year = $Year + 1900;

    return $Fixed_Year."-".$RealMonth."-".$Day;
}




sub getint {
    my ($string)=shift;
    my (@val)=unpack("CCCC",$string);

    # TODO - this needs checking !

    if (!defined($endian)||$endian==1) {
	#little endian
	return ((($val[3]*256+$val[2])*256+$val[1])*256)+$val[0];
    }
    else {
	return ((($val[0]*256+$val[1])*256+$val[2])*256)+$val[3];
    }
}


sub get_endian {
    # 0 == big-endian
    # 1 == little-endian
    return unpack("h*", pack("s", 1)) =~ /^1/;
}



sub get_mplayer_format {
    if (!defined($nrate)) {
	$nrate=$arate;
    }
    if (!defined($nchans)) {
	$nchans=$achans;
    }
    if (!defined($nasamps)) {
	$nasamps=$asamps;
    }
    if (!defined($asigned)) {
	$asigned=$signed;
    }
    if (!defined($aendian)) {
	$aendian=$endian;
    }
    if (!defined($nsigned)) {
	$nsigned=$asigned;
    }
    if (!defined($nendian)) {
	$nendian=$aendian;
    }

    if ($nasamps==8) {
	if ($nsigned==0) {
	    return "-format u8";
	}
	return "-format s8";
    }
    if ($nsigned==0) {
	if ($nendian==0) {
	    return "-format u16be";
	}
	return "-format u16le";
    }
    if ($nendian==0) {
	return "-format s16be";
    }
    return "-format s16le";
}




sub clean_old {
    return if (! -d "$tmpdir/$handle");
    chdir "$tmpdir/$handle";
    unlink <*.mgk *.bak *.pre *.tmp pause audio.* audiodump*>;
    `sync;sync;sync`;
}



sub sig_complete {
    return if (! -d $curtmpdir);
    my($status)="completed";
    foreach (@_) {
	$status.="|".$_;
    }
    `sync;sync;sync`;

    if (-d $curtmpdir) {
	&check_for_pause;
	open OUT,"> $statusfile";
	print OUT $status;
	close OUT;
	unlink $pidfile;
    }
}


sub sig_killed {
    return if (! -d $curtmpdir);
    return if (-f $statusfile);
    my($status)="killed";

    open OUT,"> $statusfile";
    print OUT $status;
    close OUT;
    unlink $pidfile;
}


sub sig_complete_audio {
    return if (! -d $curtmpdir);
    my($status)="audio_ended|";
    foreach (@_) {
	$status.="|".$_;
    }
    
    open OUT,"> $statusfile.play";
    # autoflush output
    select((select(OUT), $| = 1)[0]);
    print OUT $status;
    close OUT;

    unless ($opening_preview==1) {
	unlink $pidfile;
    }
}


sub sig_error {
    # WARNING: error strings MUST NOT contain newlines, instead you can pass up to 4 lines of text as params
    return if (! -d $curtmpdir);

    my($status)="error";
    my ($count)=0;
    foreach (@_) {
	$status.="|".$_;
	$count++;
    }
    if ($count<4) {
	$status.="|||ERROR|";
    }

    open OUT,"> $statusfile";
    print OUT $status;
    close OUT;
    unlink $pidfile;
    `sync;sync;sync`;
    exit 1;
}


sub sig_pid {
# write our pid in case we need to be cancelled
    open OUT,"> $pidfile";
    print OUT $$;   # process ID
    close OUT;
}



sub sig_progress {
# report progress of frame processing
    my $status="";
    foreach (@_) {
	if ($status eq "") {
	    $status=$_;
	}
	else {
	    $status.="|".$_;
	}
    }
    &check_for_pause;
    open OUT,"> $statusfile";
    print OUT $status;
    close OUT;
}


sub sig_clear {
    &check_for_pause;
    unlink $statusfile;
}



sub location {
    # return the location of an executable
    my ($command)=shift;
    my ($location)=`which $command 2>/dev/null`;
    chomp($location);
    $location;
}


sub rc_set_if_not_set {
    my ($key)=$_[0];
    shift (@_);
    my ($value)=join(" ",@_);
    $skip_if_exist=1;
    &rc_set($key,$value);
}

sub rc_delete {
    my ($key)=$_[0];

    $delpref=1;
    &rc_set($key,"");
}



sub rc_set {
    # set a value in the .rc file
    my ($key)=$_[0];
    shift (@_);
    my ($value)=join(" ",@_);

    my ($rcfile)=$home."/".$rc_filename;

    if (defined($prefs_file)) {
	$rcfile=$prefs_file;
    }

    if (!defined(open OUT,"> $rcfile.new") && -e $rcfile) {
	exit 3;
    }

    # autoflush output
    select((select(OUT), $| = 1)[0]);

    if (! defined ($delpref)) {
	$delpref=0;
    }

    if ($key eq "") {
	$date=&get_current_date;
	print OUT "# This file is autogenerated by $GUI_NAME on $date\n# You are strongly advised to change the values only through the GUI.\n";
    }

    #replace <$key> to </$key> with our new value
    else {
	if (!defined(open IN,"$rcfile") && -e $rcfile) {
	    exit 2;
	}
	$string="";
	$part=0;
	$found=0;
	while (<IN>) {
	    $string=$_;
	    if ($found==0||$part==1) {
		if ($part==1||$_=~ /^(<$key>)/) {
		    if ($skip_if_exist==1) {
			close IN;
			close OUT;
			unlink "$rcfile.new";
			$skip_if_exist=0;
			return;
		    }
		    if ($part==0) {
			$part=1;
			if ($delpref==0) {
			    print OUT "$1$2\n$value\n</$key>\n";
			}
			else {
			    #$date=&get_current_date;
			    #print OUT "# $key deleted by $GUI_NAME $date\n";
			}
			$string=$3;
			$found=1;
		    }
		    if ($string=~ /(<\/$key>)$/) {
			if ($delpref==0) {
			    print OUT $3;
			}
			$part=0;
		    }
		}
		elsif ($part==0) {
		    print OUT $string;
		}
	    }
	    else {
		print OUT $string;
	    }
	}
	if ($found==0&&$delpref==0) {
	    print OUT "\n<$key>\n$value\n</$key>\n";
	}
    }
    close IN;
    close OUT;
    rename $rcfile.".new",$rcfile or exit 3;
    $delpref=0;
}


sub rc_get {
    # return a value from our .rc file
    my ($key)=shift;
    my ($rcfile)=$home.'/'.$rc_filename;
    my ($string)='';

    if (defined($prefs_file)) {
	$rcfile=$prefs_file;
    }

    unless (defined(open IN,"$rcfile")) {
	print STDERR "Smogrify: Unable to read values from rc file, $rcfile\n";
	exit 2;
    }
    $part=0;
    while (<IN>) {
	if ($part==1&&$_=~ /(<\/$key>)$/) {
	    close IN;
	    return $string;
	}
	if ($part==1||$_=~ /^(<$key>)/) {
	    if ($part==1) {
		$_=~ s/\n//g;
		if ($string eq "") {
		    $string=$_;
		}
		else {
		    $string.="\n".$_;
		}
	    }
	    else {
		$part=1;
		$string=$2;
	    }
	}
    }
    close IN;
    return $string;
}



sub count_frames {
    #count number of frames using a binary search

    my $count=0,$gap=1;
    if (!defined $handle) {
	$handle=$ARGV[1];
	$curtmpdir="$tmpdir/$handle";
    }

    $name=&mkname(1);
    unless (-f "$curtmpdir/$name$img_ext") {
	return 0;
    }

    while (1) {
	$name=&mkname($count+$gap);
	if (-f "$curtmpdir/$name$img_ext") {
	    $count+=$gap;
	    $gap*=2;
	}
	else {
	    if ($gap==1) {
		last;
	    }
	    $gap/=2;
	}
    }
    return $count;
}
    


sub my_basename {
    my ($exe)=shift;
    my @parts=split(/\//,$exe);
    return $parts[-1];
}



sub write_bootstrap_file {
    #write our bootstrap file and make our tmpdir
    unlink $gui_bootstrap_file;
    unless (defined(open OUT,"> $gui_bootstrap_file")) {
	exit 4;
    }
    close OUT;
}


sub mktmpdir {
    unless (-d $tmpdir) {
	# create working directory
	umask 0;
	unless (mkdir $tmpdir,0777) {
	    unless ($gui_bootstrap_file eq "") {
		open OUT,"> $gui_bootstrap_file" or exit 4;
		print OUT "$version|$tmpdir|$msg|$msg2";
		close OUT;
	    }
	    exit 5;
	}
	umask $umask;
    }
}


sub fndset {
    /^set\./ or return;
    $in_set=1;
}



sub get_home_dir {
    return $ENV{"HOME"};
}



# get default values
sub rc_get_default {
    # return a value from our .rc file
    my ($key)=shift;
    my ($ret)="";

    if ($key eq "mplayer_play_video_command") {
	$ret=&location("mplayer");
	if (!($ret eq "")) {
	    $ret.=" -double";
	}
    }

    elsif ($key eq "sox_command") {
	$ret=&location("play");
    }

    elsif ($key eq "mplayer_audio_command") {
	$ret=&location("mplayer");
    }

    $ret;
}



sub version_check_and_upgrade {
    my $old_version=&rc_get("version");
    my $version_hash=&version_hash($old_version);

    $msg="";

    # throw a warning if using png and convert_version < 6.0.0
    if (&rc_get("default_image_format") eq "png" && $convert_version_hash<6000) {
	$msg="You are advised to upgrade to at least version 6.0 of Image Magick if using png files";
    }

    if ($version_hash>0) {
	if ($version_hash<8005) {
	    # not used now
	    &rc_delete("frontend");
	    &rc_delete("mog_auto_bak");
	    &rc_delete("plugin_dir");
	}
	if ($version_hash<9001) {
	    # convert_version is used instead now
	    &rc_delete("mogrify_version");

	    &rc_delete("effects_command");

	    # hey, now we use our own keyboard poller
	    # things are getting groovy !
	    &rc_delete("no_fast_keys");

	    # changed to "open_compression_percent"
	    &rc_delete("open_quality");

	    &rc_delete("kbd_rpt_state");
	    &rc_delete("kbd_rpt_delay");
	    &rc_delete("kbd_rpt_rate");

	    #encoder_command not used any more
	    &rc_delete("encoder_command");

	    #encoder_acodec used instead
	    &rc_delete("audio_encode_quality");

	    #encoder plugin names changed
	    $msg="Make sure you delete all the old encoder plugins and install the new ones.";
	    $msg2="Then change your encoder from Preferences / Encoders";
	}
	if ($version_hash<9006) {
	    &rc_delete("video_player");
	    &rc_delete("video_play_command");
	    &rc_delete("PAL/NTSC");
	}
	if ($version_hash<9006) {
	    &rc_delete("osc_opts");
	}
	if ($version_hash<10001005) {
	    &rc_delete("debug_encoders");
	}
	if ($version_hash<10002000) {
	    my $wmask=&rc_get("lives_warning_mask");
	    $wmask|=8192;
	    &rc_set("lives_warning_mask",$wmask);
	}
	unless ($old_version eq $version) {
	    $current_keymap=`grep \"keymap file version 4\" $lives_home_dir$default_keymap 2>/dev/null`;
	    if ($current_keymap eq "") {
		unlink "$lives_home_dir$default_keymap";
	    }
	    unless (&location("build-lives-plugin-multi") eq "") {
		`build-lives-plugin-multi custom`;
		`build-lives-plugin-multi test`;
	    }
	}
    }

    if ($startup_phase==0) {
	&rc_set("startup_phase",100);
    }

    # bless this version
    &rc_set("version",$version);
}


sub version_hash {
    my ($string)=shift;
    if ($string eq "") {
	return 0;
    }
    my ($ver_major,$ver_minor,$ver_micro)=split (/[.]/, $string,3);
    my $version_hash=($ver_major*1000+$ver_minor)*1000+$ver_micro;
    $version_hash;
}


sub RGB24_to_string {
    my ($red,$green,$blue)=@_;
    sprintf("'#%02X%02X%02X'",int($red),int($green),int($blue));
}


sub get_form_request {
    my ($plugin)=shift;
    if ($plugin eq "") {
	return &get_format_request;
    }
    else {
	return `$plugin get_format_request`;
    }
}


sub get_convert_version_hash {
    my $real_convert_command=(split(" ",$convert_command))[0];
    my $convert_version=`$real_convert_command | grep -i version`;
    $convert_version=(split(" ",$convert_version))[2];
    return &version_hash($convert_version);
}


sub weed {
    my $file;
    if (!chdir $tmpdir) {
	print STDERR "Could not clean up, directory $tmpdir is not accessible\n";
	return 0;
    }
    my $start_total=(split / /, `du -sb -B 1048567 2>/dev/null`)[0];

    use File::Find;
    opendir DIR,$tmpdir;
    while ($file=readdir(DIR)) {
	unless ($file =~ /^\./) {
	    if (-d "$tmpdir/$file") {
		if (&is_non_empty_dir("$tmpdir/$file/clips") || &is_non_empty_dir("$tmpdir/$file/layouts")) {
		    # new style sets, for now only check /clips subdir
		    unless (!defined($new_temp)||$new_temp eq "") {
			system("/bin/mv $file $new_temp/");
		    }
		}
		else {
		    $in_set=0;
		    find (\&fndset,"$tmpdir/$file/");
		    if (!$in_set) {
			`/bin/rm -rf $file`;
		    }
		    else {
			unless (-f "noprune") {
			    chdir $file;
			    &prune;
			    chdir $tmpdir;
			}
			unless (!defined($new_temp)||$new_temp eq "") {
			    system("/bin/mv $file $new_temp/");
			}
		    }
		}
	    }
	    else {
		unless (!defined($new_temp)||$new_temp eq "") {
		    if ($file =~ /^recovery/ || $file =~ /^layout/) {
			system("/bin/mv $file $new_temp/");
		    }
		}
	    }
	}
    }

    closedir DIR;

    `/bin/rm -f .* 2>/dev/null`;
    `/bin/rm -f rfx.* 2>/dev/null`;
    `/bin/rm -f /tmp/.smogval* 2>/dev/null`;
    `/bin/rm -rf /tmp/lives-symlinks 2>/dev/null`;
    my $end_total=(split / /, `du -sb -B 1048567 2>/dev/null`)[0];

    return $start_total-$end_total;
}


sub get_sox_version {
    my $soxv=`sox -h 2>&1 | grep -i sox:`;

    my $soxvv=(split(/\./,(split(" ",$soxv))[2]))[0];

    if (substr($soxvv,0,1) eq "v") {
	$soxvv=substr($soxvv,1,length($soxvv));
    }
    if ($soxvv eq "") {
	# version 12.x.x or lower
	$soxvv=0;
    }

    return $soxvv;
}


sub prune {
    $old_handle=$handle;
    $handle=$file;
    &clean_old;
    $handle=$old_handle;
}




sub clear_symlinks {
    my $linksdir="lives-symlinks/$handle/";
    
    chdir "/tmp";
    
    if (-d $linksdir) {
	# remove directory + contents
	system("/bin/rm -rf $linksdir");
    }
    
    #create dir so next step works
    system("/bin/mkdir -p $linksdir");

    # remove dir + any empty parents
    system("/bin/rmdir -p $linksdir 2>/dev/null");
}


sub is_non_empty_dir {
    my $dirname=shift;
    my $xfile;

    opendir TDIR,$dirname;
    while ($xfile=readdir(TDIR)) {
	unless ($xfile =~ /^\./) {
	    closedir TDIR;
	    return 1;
	}
    }
    
    closedir TDIR;
    return 0;
}
